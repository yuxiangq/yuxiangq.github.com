<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code4Cocoa]]></title>
  <subtitle><![CDATA[A Programer's Home]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://code4cocoa.com/"/>
  <updated>2015-12-07T08:50:21.000Z</updated>
  <id>http://code4cocoa.com/</id>
  
  <author>
    <name><![CDATA[YuxiangQ]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS实现判断程序关闭、关机的思路]]></title>
    <link href="http://code4cocoa.com/2015/10/25/iOS%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%85%B3%E9%97%AD%E3%80%81%E5%85%B3%E6%9C%BA%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://code4cocoa.com/2015/10/25/iOS实现判断程序关闭、关机的思路/</id>
    <published>2015-10-25T02:46:52.000Z</published>
    <updated>2015-12-07T08:50:21.000Z</updated>
    <content type="html"><![CDATA[<p>最近在研究竞品的时候，发现其实现了检测APP是否关闭，用户是否关机的功能。当然我们知道以iOS的情况来说，是没有API能直接做到的。不过简单想了想，觉得利用多种方式配合，或许我们还是可以「判断」关机和APP关闭的。</p>
<ol>
<li>APP使用心跳机制和服务器保持通信。</li>
<li>APP监听手机的网络状态变化，并将数据上传给服务器。</li>
<li>服务器定时利用Slient Remote Notifications判断APP是否有反应。</li>
</ol>
<p><strong>判断</strong></p>
<p>服务器发现客户端心跳不正常，判断是否有网络异常状态，如果有网络异常状态则判断为「网络异常」。<br>如果没有网络异常状态，则向APP发送Slient Remote Notifications，如果APP没响应，则判断为「关机」。<br>如果有响应，则判断为「APP关闭」</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在研究竞品的时候，发现其实现了检测APP是否关闭，用户是否关机的功能。当然我们知道以iOS的情况来说，是没有API能直接做到的。不过简单想了想，觉得利用多种方式配合，或许我们还是可以「判断」关机和APP关闭的。</p>
<ol>
<li>APP使用心跳机制和服务器保持通]]>
    </summary>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITableView实现下拉刷新]]></title>
    <link href="http://code4cocoa.com/2015/09/13/UITableView%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>http://code4cocoa.com/2015/09/13/UITableView实现下拉刷新/</id>
    <published>2015-09-13T10:45:45.000Z</published>
    <updated>2015-12-05T07:33:20.000Z</updated>
    <content type="html"><![CDATA[<p><strong>下拉刷新</strong>实在是很了不起得创意。目前几乎所有APP只要涉及刷新的功能，都会采用这种方式，这已经是刷新交互的标配。</p>
<p>在Github上有大量的开源组件能实现<strong>下拉刷新</strong>和<strong>上拉加载</strong>，在这里我推荐<strong><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a></strong>，它能帮我们很优雅的实现以上两种功能。</p>
<p>下拉刷新的原理，大家很容易理解，就是利用UITableView偏移到一定程度，然后调用刷新方法即可。但是有些童鞋可能发现了一个问题，就是UITableViewDelegate中并没有拖动相关的方法，这是怎么回事呢？其实那是因为UITableView本身继承自UIScrollView，所以我们只需要实现UIScrollViewDelegete中的- (void)scrollViewDidScroll:(UIScrollView * )scrollView方法即可。</p>
<p><pre><code><br>//只提供关键方法<br>-(void)p_InitUITableView<br>{<br>if(self.tableView==nil)<br>{<br>self.tableView=[UITableView alloc] init];<br>self.tableView.delegate=self;<br>self.tableView.datasource=self;<br>}<br>}<br>//拉动UITableView的时候会调用该方法<br>-(void)scrollViewDidScroll:(UIScrollView * )scrollView<br>{<br>//判断是否处于刷新状态<br>if(self.isLoading)<br>{<br>//获取实际内容的高度,及UITableViewCell集合的高度，包括超出屏幕部分。<br>float contentHeight=scrollView.contentSize.height;<br>//获取TableView的高度<br>float tableViewHeight=self.tableView.frame.size.height;<br>//获取展示内容的高度,如果内容高度大于UITableView高度，就以UITableView高度为准；<br>//如果内容高度小于UITableView高度，就以内容高度为准。<br>float displayHeight=contentHeight&gt;tableViewHeight?tableViewHeight:contentHeight;<br>//接下来我们需要计算，我们拉动UITableView的时候，我们的展示内容displayHeight偏移了多少。<br>//假设相对于displayHeight往上或往下偏移20%的距离及算触发刷新。<br>if ((displayHeight - scrollView.contentSize.height + scrollView.contentOffset.y) / displayHeight &gt; 0.2)<br>{<br>// 调用上拉加载方法，在这里可以处理一些刷新动画<br>}<br>//scrollView.contentOffset.y表示整个内容在y轴上的偏移量，下拉的时候内容是向y轴负方向移动<br>//所以计算的时候要取反<br>if (- scrollView.contentOffset.y / self.tableView.frame.size.height &gt; 0.2)<br>{<br>// 调用下拉刷新方法，在这里可以处理一些刷新动画<br>}<br>}<br></code></pre><br>另外我们在添加下拉刷新的箭头的时候，Header不要添加在TableViewHeader上，要添加在UITableView的subView中。否则Header会一直在顶端，不会被覆盖。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>下拉刷新</strong>实在是很了不起得创意。目前几乎所有APP只要涉及刷新的功能，都会采用这种方式，这已经是刷新交互的标配。</p>
<p>在Github上有大量的开源组件能实现<strong>下拉刷新</strong>和<strong>上拉加载</st]]>
    </summary>
    
      <category term="UITableView" scheme="http://code4cocoa.com/tags/UITableView/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
      <category term="下拉刷新" scheme="http://code4cocoa.com/tags/%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebAPP将迎来一个好时代]]></title>
    <link href="http://code4cocoa.com/2015/08/29/WebAPP%E5%B0%86%E8%BF%8E%E6%9D%A5%E4%B8%80%E4%B8%AA%E5%A5%BD%E6%97%B6%E4%BB%A3/"/>
    <id>http://code4cocoa.com/2015/08/29/WebAPP将迎来一个好时代/</id>
    <published>2015-08-29T07:47:07.000Z</published>
    <updated>2015-12-04T06:44:34.000Z</updated>
    <content type="html"><![CDATA[<p>随着4G网络的普及，以及手机性能、浏览器性能的提升，WebAPP正迎来自己的时代。</p>
<p>想起2-3年前的时候，就有很多人在说WebAPP将崛起与NativeAPP平分秋色。但事实是WebAPP并没有真正占据一定份额。主要原因莫过于响应速度和体验远逊于NativeAPP，当然也有优化到极端的例子，效果可以说无限接近NativeAPP，但那毕竟是少数。大多数的WebAPP采用「JQueryMobile」、「SenchaTouch」等框架，在具体研发中遇到过的坑那是相当多，尝试过开发商业项目的童鞋应该心有余悸。</p>
<p>最近一年，4G网络的加紧推广及流量价格的降低，解决了WebAPP很大的一个短板，也让我们看到了WebAPP崛起的希望。其实移动网络的加速，对整个APP开发都是有益的，对于小团队来说，就不用将太多的精力投入到基础通讯的优化上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着4G网络的普及，以及手机性能、浏览器性能的提升，WebAPP正迎来自己的时代。</p>
<p>想起2-3年前的时候，就有很多人在说WebAPP将崛起与NativeAPP平分秋色。但事实是WebAPP并没有真正占据一定份额。主要原因莫过于响应速度和体验远逊于NativeA]]>
    </summary>
    
      <category term="WebAPP" scheme="http://code4cocoa.com/tags/WebAPP/"/>
    
      <category term="行业发展" scheme="http://code4cocoa.com/tags/%E8%A1%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[手机是如何定位的]]></title>
    <link href="http://code4cocoa.com/2015/06/19/%E6%89%8B%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E7%9A%84/"/>
    <id>http://code4cocoa.com/2015/06/19/手机是如何定位的/</id>
    <published>2015-06-19T14:00:10.000Z</published>
    <updated>2015-12-07T08:51:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们目前了解到的手机定位方式，主要有四种：GPS、A-GPS、Wi-Fi、基站定位。</p>
<h4 id="GPS">GPS</h4><p>即全球定位系统，它是利用GPS定位卫星，在全球范围内实时进行定位、导航的系统。民用定位精度为10米左右，定位精度取决于上方遮盖物，周围环境，当地政策等。所以室内是无法使用GPS进行定位的。在空旷的地方GPS定位精度高于城市中。</p>
<p><em>优点:精度高、不依赖网络。</em></p>
<p><em>缺点:定位速度慢，因为GPS的使用需要搜索卫星，并且不同的设备，不同的环境搜索卫星的速度都会不一样。所以当需要快速定位，对位置精度要求不高的场景，GPS不是一个很好的选择。</em></p>
<pre><code>
关于手机GPS和车载GPS速度的比较:

GPS定位的时候是需要通过卫星的位置、用户到卫星的距离来确定用户的位置。而卫星在运行时轨道不可避免的会产生误差和变动，这就需要用户使用最新的卫星轨道参数来求得卫星位置，卫星的这些参数叫做星历。GPS定位的快慢，和获取星历的快慢，有直接关系。

在有网络连接的情况下，手机可以从网络服务器下载星历，从而提高首次定位的速度(几秒到几十秒)，而没有网络的时候，手机GPS只能像车载GPS一样从卫星上下载星历，传输速率低很多，首次定位时长增加到2-5分钟。

用户GPS设备，在长时间关闭(或丢失信号)后，星历可能发生较大变化，甚至完全不同，或者有些GPS设备没有关闭后存储星历的功能，就需要下载新的星历，这就是「冷启动」。而热启动就是短时间关闭或丢失信号之后再进行定位，星历可能只需要略加变动或没有变动，不需要花大量的时间下载星历，可以直接用存储的星历进行解算。

</code></pre>

<h4 id="A-GPS(Assisted_GPS)">A-GPS(Assisted GPS)</h4><p>A-GPS（Assisted GPS：辅助全球卫星定位系统）是结合GSM/GPRS与传统卫星定位，利用基地台代送辅助卫星信息，以缩减GPS芯片获取卫星信号的延迟时间，受遮盖的室内也能借基地台讯号弥补，减轻GPS芯片对卫星的依赖度。简而言之，就是有网络辅助的GPS。</p>
<p>A-GPS解决方案的优势主要在其定位精度上，在室外等空旷地区，其精度在正常的GPS工作环境下，可达10米左右，堪称目前定位精度最高的一种定位技术。该技术的另一优点为：首次捕获GPS信号的时间一般仅需几秒，不像GPS的首次捕获时间可能要2～3分钟。</p>
<p><em>优点:定位速度快、精度高。</em></p>
<p><em>缺点:不支持室内定位、依赖网络。</em></p>
<h4 id="Wi-Fi定位">Wi-Fi定位</h4><p>Wi-Fi定位的原理并不是很多人想的那样依靠IP地址定位，它实际是利用Wi-Fi信号来定位。当你的手机能收到某个Wi-Fi信号时，手机就会去服务器查找这个Wi-Fi信号的位置，然后再通过Wi-Fi信号强度进行纠正。比如在iOS中，系统就会提示用户，开启Wi-Fi以便获取更精确的位置信息。</p>
<pre><code>
关于Wi-Fi信息的采集，Apple会使用专门的采集车，沿街道扫描Wi-Fi信号，并将Wi-Fi信号的强度、经纬度等相关信息上传到服务器。同时当我们的手机连接到某个Wi-F时i，手机系统也会记录下该Wi-Fi的相关信息，并尝试获取经纬度(例如通过基站定位)然后将其上传。百度地图、谷歌地图等地图相关的APP，差不多都有这样的采集措施。
</code></pre>

<p><em>优点:可室内定位，速度较快，定位精度较高、不依赖网络。</em><br><em>缺点:定位精度稳定性不高</em></p>
<h4 id="基站定位">基站定位</h4><p>基站定位技术一般应用于手机，它是通过电信移动运营商的网络(如GSM网)获取移动终端用户的位置信息的技术。<br>基站定位的大致原理为：移动电话测量不同基站的下行导频信号，得到不同基站下行导频的TOA(Time of Arrival，到达时刻)或TDOA(Time Difference of Arrival，到达时间差)，根据该测量结果并结合基站的坐标，一般采用三角公式估算法，就能够算出移动电话的位置。实际的位置估计算法要考虑多基站(3个或3个以上)定位的情况，一般而言，附近基站数目越多，定位精度越高。</p>
<p><em>优点：可以室内定位，定位速度快、不依赖网络。</em></p>
<p><em>缺点：定位精度受基站覆盖率影响，定位精度不稳定。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们目前了解到的手机定位方式，主要有四种：GPS、A-GPS、Wi-Fi、基站定位。</p>
<h4 id="GPS">GPS</h4><p>即全球定位系统，它是利用GPS定位卫星，在全球范围内实时进行定位、导航的系统。民用定位精度为10米左右，定位精度取决于上方遮盖物，周]]>
    </summary>
    
      <category term="GPS" scheme="http://code4cocoa.com/tags/GPS/"/>
    
      <category term="定位" scheme="http://code4cocoa.com/tags/%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记七]]></title>
    <link href="http://code4cocoa.com/2015/05/21/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
    <id>http://code4cocoa.com/2015/05/21/Swift学习笔记七/</id>
    <published>2015-05-21T13:32:56.000Z</published>
    <updated>2015-12-07T09:23:48.000Z</updated>
    <content type="html"><![CDATA[<h4 id="关于Swfit中的构造器">关于Swfit中的构造器</h4><p><strong>构造器</strong>其实就是我们在其他语言中常说的<strong>构造函数</strong>。</p>
<pre>与Objective-C中**构造函数**不同的是，Swfit的**构造器**无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化(这个初始化过程包括为实例中属性值设置初始值等)。</pre>
<pre>当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观测器（property observers）。</pre>
**构造器**的最简形式类似于一个不带任何参数的实例方法，以关键字*init*命名，例如：
<pre><code>
//在这里我们定义一个结构体
struct test{
var testNum:Double
init(){
testNum=1.1
}
}
//该结构体定义了一个不带参数的构造器，并且将属性testNum的值设置为1.1。
</code></pre>
你也可以在定义构造器时提供构造参数，为其提供定制化构造所需值的类型和名字。构造器参数的功能和语法跟函数和方法参数相同，例如：
<pre><code>
struct test{
var testNum:Double
init(fromTestNum t:Double){
testNum=t
}
}
</code></pre>
<pre>
跟函数和方法参数相同，构造参数也存在一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。所以在调用构造器时，主要通过构造器中的参数名和类型来确定需要调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名，就相当于在每个构造参数之前加了一个哈希符号。
</pre>






]]></content>
    <summary type="html">
    <![CDATA[<h4 id="关于Swfit中的构造器">关于Swfit中的构造器</h4><p><strong>构造器</strong>其实就是我们在其他语言中常说的<strong>构造函数</strong>。</p>
<pre>与Objective-C中**构造函数**不同的是，Swfit]]>
    </summary>
    
      <category term="Swift" scheme="http://code4cocoa.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义UITableViewCell，使用VFL布局]]></title>
    <link href="http://code4cocoa.com/2015/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89UITableViewCell%EF%BC%8C%E4%BD%BF%E7%94%A8VFL%E5%B8%83%E5%B1%80/"/>
    <id>http://code4cocoa.com/2015/04/12/自定义UITableViewCell，使用VFL布局/</id>
    <published>2015-04-12T12:57:39.000Z</published>
    <updated>2015-12-07T09:19:36.000Z</updated>
    <content type="html"><![CDATA[<p>自定义UITableViewCell自动布局的文章网上又挺多的，但是大部分都是采用的xib进行布局，所以这一块其实水挺深的。经过自己的实践和不断的查找资料，终于实现了使用纯VFL布局，实现方式在这里和大家一起分享一下，<a href="https://github.com/yuxiangq/UITableViewCell4VFL/commits?author=yuxiangq" target="_blank" rel="external">Demo比较简单</a></p>
<ul>
<li><p>首先我们新建一个工程，命名为CustomCellWithVFLDemo，如下图所示：<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/CustomCellVFL/create_project_1.png" alt="image"><br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/CustomCellVFL/create_project_2.png" alt="image"></p>
</li>
<li><p>让我们的ViewController继承UITableViewController。继承UITableViewController能帮我们省不少事情。<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/CustomCellVFL/viewcontroller_uitableviewcontroller.png" alt="image"></p>
</li>
<li><p>新建CustomCell，我们在其中新建一个UILabel，叫contentLabel，用于展示文本数据并允许换行。</p>
<script src="https://gist.github.com/yuxiangq/96c5ffeb2ab9d718a33e.js"></script>
</li>
<li><p>为contentLabel设置约束，这里我们的约束可以看做Margin(5,5,5,5)。</p>
<script src="https://gist.github.com/yuxiangq/dc9faab124f1eedf82a8.js"></script>
</li>
<li><p>在ViewController中添加一个原型cell，动态计算高度的时候使用。</p>
<script src="https://gist.github.com/yuxiangq/6c282d9899fe28fe59e4.js"></script>

</li>
</ul>
<pre>
涉及换行的UILabel，请一定要注意**preferredMaxLayoutWidth**属性的设置，否则换行会出问题。
</pre>


]]></content>
    <summary type="html">
    <![CDATA[<p>自定义UITableViewCell自动布局的文章网上又挺多的，但是大部分都是采用的xib进行布局，所以这一块其实水挺深的。经过自己的实践和不断的查找资料，终于实现了使用纯VFL布局，实现方式在这里和大家一起分享一下，<a href="https://github.com/]]>
    </summary>
    
      <category term="UITableViewCell" scheme="http://code4cocoa.com/tags/UITableViewCell/"/>
    
      <category term="VFL" scheme="http://code4cocoa.com/tags/VFL/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的2014总结]]></title>
    <link href="http://code4cocoa.com/2015/02/04/%E6%88%91%E7%9A%842014%E6%80%BB%E7%BB%93/"/>
    <id>http://code4cocoa.com/2015/02/04/我的2014总结/</id>
    <published>2015-02-04T07:25:13.000Z</published>
    <updated>2015-12-07T09:11:21.000Z</updated>
    <content type="html"><![CDATA[<p>2014已经结束了，在这元旦假期的最后一天，就让我来总结一下自己去年技术上的收获及见闻。</p>
<h1 id="iOS">iOS</h1><p>去年我的主要角色是整个团队的iOS工程师及技术总负责人。当然同时还会兼职产品经理，运维等其他角色o(╯□╰)o。</p>
<h2 id="VFL">VFL</h2><p>首先是学会使用了VFL，真是布局神器，强烈推荐。为此我将产品中大部分的布局都使用VFL进行了重写。这感觉，谁用谁知道。</p>
<h2 id="ARC">ARC</h2><p>今年初的时候产品不再支持iOS4(我的决定^_^)，于是启用了ARC。这感觉，谁用谁知道</p>
<h2 id="Github"><a href="https://github.com/yuxiangq" target="_blank" rel="external">Github</a></h2><p>在上面发现了不少优秀的代码，自己也参与了一些。这才是程序员的SNS。</p>
<h3 id="XHImageViewer"><a href="https://github.com/JackTeam/XHImageViewer" target="_blank" rel="external">XHImageViewer</a></h3><p>一个图片查看控件，支持图片缩放。我为其添加了Block支持。目前正在研究用其查看超大图片。</p>
<h3 id="AFNetworking">AFNetworking</h3><p>将产品的网络请求全部替换为AFNetworking 2.0，因为前期对网络请求层进行了一次封装，所以替换起来很顺利。</p>
<h3 id="NumberTextField"><a href="https://github.com/yuxiangq/NumberTextField" target="_blank" rel="external">NumberTextField</a></h3><p>自己写的一个只允许输入数字的控件，在新的一年中还需要将其完善。</p>
<h3 id="CocoaPods">CocoaPods</h3><p>一个优秀的第三方库管理工具，今年初的时候产品的大部分第三方库已经用其管理。</p>
<h3 id="Alfred">Alfred</h3><p>Mac下的优秀的快速启动工具，目前我已经是它的重度用户。配合workflow，实在是神器。自己也在用Python为其编写插件。</p>
<h3 id="Swift">Swift</h3><p>有条不紊的学习中，因为自己对C#的熟悉，所以很多Swift的新特性个人感觉并不是很惊艳。</p>
<h1 id="-Net">.Net</h1><p>去年写.Net的时间较少，更多的是在技术大方向上的把握。</p>
<h2 id="WebAPI">WebAPI</h2><p>一直在计划将服务器框架由WCF替换为WebAPI，在年中的时候进行了框架搭建，可惜的是因为产品功能迭代较快，没有时间完成框架替换。</p>
<h2 id="Nuget">Nuget</h2><p>在新服务器工程中使用的引用管理工具。</p>
<h2 id="Dapper"><a href="https://github.com/yuxiangq/dapper-dot-net" target="_blank" rel="external">Dapper</a></h2><p>一个轻量级高效率的ORM框架，重要的是针对MySQL的支持同样优秀。相较于EF的繁琐，对于习惯使用ADO.NET的朋友来说，该框架实在是太合适了。</p>
<h1 id="阅读">阅读</h1><p>14年阅读了挺多经典的书籍，还有部分书没来得及读。除了技术相关书籍还读了部分马伯庸的小说，真的非常好。</p>
<h2 id="Effective_Objective-C_2-0"><a href="http://book.douban.com/subject/21370593/" target="_blank" rel="external">Effective Objective-C 2.0</a></h2><p>一本很棒的书，讲了很多有关Objective-C的技巧，不过翻译挺烂的。</p>
<h2 id="文明之光"><a href="http://book.douban.com/subject/25902942/" target="_blank" rel="external">文明之光</a></h2><p>吴军老师的书，作为一名IT工作者，开阔的视野是必不可少的，推荐阅读。</p>
<h2 id="ASP-NET_Web_API_2框架揭秘"><a href="http://book.douban.com/subject/25923644/" target="_blank" rel="external">ASP.NET Web API 2框架揭秘</a></h2><p>讲解WebAPI的书，目前主要当词典用。</p>
<h2 id="菊与刀"><a href="http://book.douban.com/subject/1022238/" target="_blank" rel="external">菊与刀</a></h2><p>从美国人的角度来看日本的书。</p>
<h2 id="死于技术：索尼衰亡启示"><a href="http://book.douban.com/subject/25835910/" target="_blank" rel="external">死于技术：索尼衰亡启示 </a></h2><p>索尼确实已经衰落了，卖掉了经典的VAIO，这本书全面的剖析了索尼衰落的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2014已经结束了，在这元旦假期的最后一天，就让我来总结一下自己去年技术上的收获及见闻。</p>
<h1 id="iOS">iOS</h1><p>去年我的主要角色是整个团队的iOS工程师及技术总负责人。当然同时还会兼职产品经理，运维等其他角色o(╯□╰)o。</p>
<h2]]>
    </summary>
    
      <category term="个人总结" scheme="http://code4cocoa.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记六]]></title>
    <link href="http://code4cocoa.com/2015/02/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
    <id>http://code4cocoa.com/2015/02/01/Swift学习笔记六/</id>
    <published>2015-02-01T14:02:12.000Z</published>
    <updated>2015-12-07T09:24:38.000Z</updated>
    <content type="html"><![CDATA[<p>Swift中的枚举拥有很棒的特性，至少以前我是没有接触过的。</p>
<p>####枚举语法####<br>使用<strong>enum</strong>关键字，并将其整个定义放在大括号内：</p>
<pre><code>
enum demo{
//定义枚举相关类容
}
</code></pre>
假设我们定义指南针的四个方向：
<pre><code>
enum CompassPoint {
case North
case South
case East
case West
}
</code></pre>
一个枚举中被定义的值是枚举的**成员值**(或者**成员**)。
**case**关键字表明新的一样关键字被定义。

多个成员值也可以出现在同一行上，用逗号隔开：
<pre><code>
enum CompassPoint {
case North,South,East,West
}

//使用方法
var directionToHead = CompassPoint.West
directionToHead = .North
</code></pre>

<blockquote>
<p>注意：<br>不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的CompassPoints例子中，North，South，East和West不是隐式的等于0，1，2和3。相反的，这些不同的枚举成员在CompassPoint的一种显示定义中拥有各自不同的值。</p>
</blockquote>
<p>####相关值####<br>Swift的枚举可以存储任何类型的相关值，如果需要的话每个成员的数据类型是可以不同的。</p>
<p>比如我们可以定义两种商品条码的枚举：</p>
<p><pre><code><br>enum Barcode {<br>case UPCA(Int, Int, Int)<br>case QRCode(String)<br>}<br></code></pre><br>然后可以使用任何一种条码类型创建新的条码：</p>
<p><pre><code><br>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)<br>productBarcode = .QRCode(“ABCDEFGHIJKLMNOP”)<br>//使用Switch-case<br>switch productBarcode {<br>case .UPCA(let numberSystem, let identifier, let check):<br>println(“UPC-A with value of (numberSystem), (identifier), (check).”)<br>case .QRCode(let productCode):<br>println(“QR code with value of (productCode).”)<br>}<br></code></pre></p>
<p>####原始值####<br>作为相关值的替代，枚举成员可以被默认值（称为原始值）预先填充，其中这些原始值具有相同的类型。</p>
<p>这是一个枚举成员存储原始ASCII的例子：</p>
<p><pre><code><br>enum ASCIIControlCharacter: Character {<br>case Tab = “\t”<br>case LineFeed = “\n”<br>case CarriageReturn = “\r”<br>}<br></code></pre><br>原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。当整型值被用于原始值，如果其他枚举成员没有值时，它们会自动递增。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift中的枚举拥有很棒的特性，至少以前我是没有接触过的。</p>
<p>####枚举语法####<br>使用<strong>enum</strong>关键字，并将其整个定义放在大括号内：</p>
<pre><code>
enum demo{
//定义枚举相关类容
}
<]]>
    </summary>
    
      <category term="Swift" scheme="http://code4cocoa.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pocket、Instapaper、Readability的比较]]></title>
    <link href="http://code4cocoa.com/2015/01/25/Pocket%E3%80%81Instapaper%E3%80%81Readability%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://code4cocoa.com/2015/01/25/Pocket、Instapaper、Readability的比较/</id>
    <published>2015-01-25T10:47:54.000Z</published>
    <updated>2015-12-07T09:22:48.000Z</updated>
    <content type="html"><![CDATA[<p>在接触「稍后读」软件之前，我一直是使用Evernote来保存暂时无法阅读的文章。</p>
<p>大概是在两年前，我使用了第一款稍后读类的软件。当时自己入手了一台TouchPad(现在想起来相当后悔没有入手iPad啊)，刷成Android后主要用来看电子书和新闻，还用它在公司内部分享上查看演讲提纲(逼格很高啊)。这款APP是由原淘宝工程师开发的一款软件，叫<a href="http://www.udee.cn/" target="_blank" rel="external">uDee云阅读</a>。貌似已经挂了，官网已经变成建站系统了o(╯□╰)o。相关的介绍可以看这里<a href="http://www.36kr.com/p/99352.html" target="_blank" rel="external">36kr关于uDee云阅读的介绍</a>。</p>
<p>后来我入手了The New iPad，TouchPad就送给老爸看电影了。在iOS上我开始使用<a href="https://getpocket.com/" target="_blank" rel="external">Pocket</a>，那个时候还叫Read it later。用了一段时间后发现Pocket对CocoaChina支持不是很好，只能抓取到标题，查看内容的时候还得跳转到原网页，实在是麻烦，于是开始寻找其他类似产品。</p>
<p>某天在朋友手机上看到<a href="https://www.instapaper.com/" target="_blank" rel="external">Instapaper</a>，于是果断收了它(当时还是收费的)，完美支持CocoaChina，而且Instapaper的图标也比Pocket好看，所以开始同时使用二者，Pocket主力，Instapaper辅助。</p>
<p>不久入了Reeder，配合着两大神器，让我阅读了不少好文。但是Reeder也无法完整显示CocoaChina的内容，每次阅读的时候我都要先保存到Instapaper，实在是麻烦。后来无意中点了一下内容上方的小板凳图标，发现竟然将内容完整的显示出来了。后来知道了那是<a href="https://www.readability.com/" target="_blank" rel="external">Readability</a>，果断入手。</p>
<p>于是三大稍后读神器都被我凑齐了。用了一段时间后有些感悟，想和大家一起分享。</p>
<p><strong>Pocket</strong></p>
<p>我用得最久的稍后读类APP。 支持Chrome插件，通过插件保存网页。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20%E5%88%97%E8%A1%A8.PNG" alt="image"><br>文章列表界面清爽简洁，是我喜欢的风格。在列表界面提供搜索栏，很方便。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20%E8%8F%9C%E5%8D%95.PNG" alt="image"><br>软件的层级架构采用抽屉式结构，给了内容更多的展示空间。同时设置里面提供深色主题，方便夜晚阅读。唯一的遗憾是主题颜色不支持自动切换。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20%E7%BD%91%E9%A1%B5.png" alt="image"><br>Web端配色和APP保持一致，简洁不失优雅。并且Web端提供平铺和列表两种展示方式。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20Mac.png" alt="image"><br>Pocket也是三款软件中唯一有Mac客户端的。</p>
<p><strong>Instapaper</strong></p>
<p>个人认为是最精致的稍后读类APP。利用JS脚本保存内容，不支持浏览器插件。需要占用一个标签栏位置，这是让我很不爽的地方。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Instapaper%20%E5%88%97%E8%A1%A8.PNG" alt="image"><br>文章列表简洁，整个界面更偏平，可惜的是不支持搜索。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Instapaper%20%E8%8F%9C%E5%8D%95.PNG" alt="image"><br>菜单仍然是抽屉式结构，搜索功能隐藏在了这里。其他东西和Pocket大同小异。同时支持深色主题(目前包含四款主题)，更令人欣喜的是，Instapaper可以根据您的位置(需要用到GPS)和日落时间，自动调整主题的颜色。这真的是非常棒的功能。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Instapaper%20Web.png" alt="image"><br>Web端的整体布局和APP差异不大，唯一的变化是将搜索栏放到了列表上。</p>
<p><strong>Readability</strong></p>
<p>我的感觉是抓取能力最强的了，但是界面不讨个人喜欢。支持Chrome插件。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Readability%20%E5%88%97%E8%A1%A8.PNG" alt="image"><br>支持搜索及分类，较Instapaper和Pocket都更强大，可以说是结合了二者的有点。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/readability%20%E8%8F%9C%E5%8D%95.PNG" alt="image"><br>同样是抽屉式侧拉菜单o(╯□╰)o，非常简洁，另外我不是很喜欢那种全红的背景。</p>
<p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Readability%20Web.png" alt="image"><br>整体布局和APP类似，可惜的是没有了搜索功能。</p>
<p><strong>PS:以上就是我使用了三款APP后的一些浅薄看法。其实说起来它们对于我来说，都有一个很致命的缺点。就是对于代码块的处理都不尽如人意。本来文章中排版很舒服的代码，经过它们处理后就和普通文本混杂在一起，实在是一件很头痛的事情，希望能有一款稍后读类的APP能针对程序员定制。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在接触「稍后读」软件之前，我一直是使用Evernote来保存暂时无法阅读的文章。</p>
<p>大概是在两年前，我使用了第一款稍后读类的软件。当时自己入手了一台TouchPad(现在想起来相当后悔没有入手iPad啊)，刷成Android后主要用来看电子书和新闻，还用它在公司]]>
    </summary>
    
      <category term="App比较" scheme="http://code4cocoa.com/tags/App%E6%AF%94%E8%BE%83/"/>
    
      <category term="稍后读" scheme="http://code4cocoa.com/tags/%E7%A8%8D%E5%90%8E%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NumberTextField]]></title>
    <link href="http://code4cocoa.com/2015/01/12/NumberTextField/"/>
    <id>http://code4cocoa.com/2015/01/12/NumberTextField/</id>
    <published>2015-01-12T12:46:26.000Z</published>
    <updated>2015-12-07T09:21:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="NumberTextField"><a href="https://github.com/yuxiangq/NumberTextField" target="_blank" rel="external">NumberTextField</a></h1><p>这是我做的一个只能输入数字的控件。<br>可以限制输入的数字长度及小数点位数。</p>
<h2 id="使用方法">使用方法</h2><p><script src="https://gist.github.com/yuxiangq/71a2ac1dabac7b4fa556.js"></script></p>
<h3 id="特性">特性</h3><ul>
<li><p>去除数字前多余的0。例如，输入000123，当控件失去焦点，或者通过text获取值的时候，数字会被处理为123。<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/before.png" alt="image"><br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/after.png" alt="image"></p>
</li>
<li><p>小数自动补0。例如，输入.123，当控件失去焦点，或者通过text获取值的时候，数字会处理为0.123。<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/dotbefore.png" alt="image"><br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/dotafter.png" alt="image"></p>
</li>
</ul>
<h3 id="函数">函数</h3><p><pre><code><br>-(NSString*)trimText;<br></code></pre><br>调用该函数可以直接获取经过处理的数字。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="NumberTextField"><a href="https://github.com/yuxiangq/NumberTextField" target="_blank" rel="external">NumberTextField</a></h1><p>这是我]]>
    </summary>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
      <category term="自定义控件" scheme="http://code4cocoa.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记五]]></title>
    <link href="http://code4cocoa.com/2015/01/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <id>http://code4cocoa.com/2015/01/01/Swift学习笔记五/</id>
    <published>2015-01-01T09:29:59.000Z</published>
    <updated>2015-12-07T09:06:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="函数的定义及调用">函数的定义及调用</h1><p>我们使用func关键字来定义函数:</p>
<pre><code>

func test( / * 这里是函数参数，通常如此定义  parameter:String * / )->String{
return "test"
}

test() //调用函数
</code></pre>

<h1 id="默认参数值">默认参数值</h1><p>给函数的参数定义默认值的方式和C#是一样的:</p>
<pre><code>
func test(s:string= "defaultValue")->String {
return s;//如果s没有传值，则会返回defaultValue
}
</code></pre>

<h1 id="可变参数">可变参数</h1><p>用来输入不确定数量的参数，但是参数的类型必须一致:</p>
<pre><code>
func test(numbers:Double...)->Double {
var total: Double = 0
for number in numbers {
total += number
}
return total
}
</code></pre>
**注意:一个函数至多能有一个可变参数，而且它必须是参数表中最后的一个。这样做是为了避免函数调用时出现歧义。**

# 常量参数和变量参数
这是要注意的是，函数中默认的参数为常量参数是不可以被重新赋值的。变量参数则需要显示定义。
<pre><code>
func test(s:String)->String{
s="test" //这里会报错，参数s为常量参数，不能被重新赋值
return s
}

func test(/ * 显示定位为变量 * /var s:String)->String{
s="test" //正常
return s
}
</code></pre>
**注意： 对变量参数所进行的修改在函数调用结束后便消失了，并且对于函数体外是不可见的。变量参数仅仅存在于函数调用的生命周期中。**

# 输入输出参数
这个和C#中的**ref,out**是类似的。如果你需要一个参数能在函数体内被修改，并且在函数调用结束后修改仍然存在，就需要使用**inout**关键字来定义参数。
<pre><code>
//交换两个变量的值
func swapTwoInts(inout a: Int, inout b: Int) {
let temporaryA = a
a = b
b = temporaryA
}
</code></pre>

<h1 id="函数类型">函数类型</h1><p>函数其实就是C#中的委托类型，也就是我们所说的函数指针。当然它相较于函数指针是类型安全的。</p>
<p><pre><code><br>func addTwoInts(a: Int, b: Int) -&gt; Int {<br>return a + b<br>}</code></pre></p>
<p>var mathFunction: (Int, Int) -&gt; Int = addTwoInts //mathFunction就是指向addTowInts函数的变量<br><br>如果我们要用一个变量来表示addTowInts这个函数，那么这个变量的类型就是<strong>(Int, Int) -&gt; Int</strong>，可以读作“这个函数类型，它有两个 Int 型的参数并返回一个 Int 型的值。”。<br>函数类型也是可以作为函数参数或函数返回值的。</p>
<h1 id="嵌套函数">嵌套函数</h1><p>默认情况下，嵌套函数是对外界不可见的，但是可以被他们封闭函数（enclosing function）来调用。一个封闭函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数的定义及调用">函数的定义及调用</h1><p>我们使用func关键字来定义函数:</p>
<pre><code>

func test( / * 这里是函数参数，通常如此定义  parameter:String * / )->String{
return "]]>
    </summary>
    
      <category term="Swfit" scheme="http://code4cocoa.com/tags/Swfit/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lock，一款有趣的应用]]></title>
    <link href="http://code4cocoa.com/2014/12/19/Lock%EF%BC%8C%E4%B8%80%E6%AC%BE%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://code4cocoa.com/2014/12/19/Lock，一款有趣的应用/</id>
    <published>2014-12-19T12:36:07.000Z</published>
    <updated>2015-12-07T09:04:42.000Z</updated>
    <content type="html"><![CDATA[<p>今天发现了一款有趣的应用，名字叫<a href="http://www.nearlock.me/" target="_blank" rel="external">Near Lock</a>。它有Mac版和iPhone版，二者是配合使用的。</p>
<p>它能让我们优雅的通过iPhone来解锁Mac。你只需要将iPhone带在身上，当你靠近自己的Mac的时候，它就是解锁状态，当你离开Mac的时候它又会自动锁上。</p>
<p>Pro版在中国区市场是25块，它能在后台运行。</p>
<p>经过我的体验，距离设置在2米左右比较合适。如果使用默认的1米，当手机刚连接上的时候，蓝牙测距不是很稳定，会在1米 ~ 2米直接跳动，导致一会儿锁屏，一会儿解锁。另外如果离开电脑时间较长再回来的话，蓝牙连接有很大的几率连接不上，希望以后的版本会有所改进。总的来说还是一款很不错的软件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天发现了一款有趣的应用，名字叫<a href="http://www.nearlock.me/" target="_blank" rel="external">Near Lock</a>。它有Mac版和iPhone版，二者是配合使用的。</p>
<p>它能让我们优雅的通过]]>
    </summary>
    
      <category term="Mac APP" scheme="http://code4cocoa.com/tags/Mac-APP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UICollectionViewController的用法]]></title>
    <link href="http://code4cocoa.com/2014/12/14/UICollectionViewController%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://code4cocoa.com/2014/12/14/UICollectionViewController的用法/</id>
    <published>2014-12-14T14:16:58.000Z</published>
    <updated>2015-12-07T09:10:03.000Z</updated>
    <content type="html"><![CDATA[<p>UICollectionView和UICollectionViewController是iOS6中新增加的控件，主要用于复杂的布局。你可以简单的把它理解为Grid。<br>在最近的版本中，我在做表单界面的时候，放弃了UITableViewController，改用UICollectionViewController来进行布局，个人感觉挺好用的，在这里我简单给大家分享一下UICollectionViewController的用法。</p>
<p><strong>首先请大家注意的是，记得为UICollectionView的collectionViewLayout属性设置UICollectionViewLayout的子类。否则是会报错的。</strong></p>
<p>UICollectionView的使用方式与UITableView相比没有什么区别，都是DataSource为View提供数据源，告诉View要显示什么东西以及如何显示他们，Delegate提供一些样式的小细节及用户交互的响应。</p>
<p><strong>初始化UICollectionView</strong></p>
<p><script src="https://gist.github.com/yuxiangq/93fdc5d139747b410488.js"></script><br><strong>UICollectionViewDataSource回调方法</strong></p>
<p><script src="https://gist.github.com/yuxiangq/0c5aa8c4dd9ebc97047a.js"></script><br>以上三个方法都是UICollectionViewDataSource的基本方法，这些方法在UITableViewDataSource中也是有的，所以使用起来难度不大。<br>另外我们需要注意的是控制Cell尺寸的方法并不在UIcollectionViewDelegate的回调中，而是在UICollectionViewDelegateFlowLayout中</p>
<pre><code>
- (CGSize)collectionView:(UICollectionView * )collectionView layout:(UICollectionViewLayout* )collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath * )indexPath;
</code></pre>

<p>关于UICollectionView中的Supplementary Views和Decoration Views我还没有用到。目前了解到的是Supplementary Views类似UITableView中的Header和Footer。Decoration Views用作背景展示。<br>因为UICollectionView比UITableView复杂得多，所以它的布局样式并不是通过Style来改变，而是通过UICollectionViewLayout，这也是UICollectionView的精髓所在。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>UICollectionView和UICollectionViewController是iOS6中新增加的控件，主要用于复杂的布局。你可以简单的把它理解为Grid。<br>在最近的版本中，我在做表单界面的时候，放弃了UITableViewController，改用UICol]]>
    </summary>
    
      <category term="UICollectionViewController" scheme="http://code4cocoa.com/tags/UICollectionViewController/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于如何学习一门新语言]]></title>
    <link href="http://code4cocoa.com/2014/12/05/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E8%AF%AD%E8%A8%80/"/>
    <id>http://code4cocoa.com/2014/12/05/关于如何学习一门新语言/</id>
    <published>2014-12-05T14:53:35.000Z</published>
    <updated>2015-12-07T09:08:39.000Z</updated>
    <content type="html"><![CDATA[<p>作为一名程序员，我们肯定会在必要的时候学习一门新的编程语言，这个时候好的学习方法会帮助我们节省很多时间，在这里谈谈我的学习方法。</p>
<p>####快速了解语法####<br>我通常会快速了解该门语言的语法，并将其和已学会的语言进行比较。比如我在学习Objective-C的时候就是将其和C#进行比较，思考两者的差异。<br>C#中的委托，在Objective-C中有什么可以实现？<br>C#中的泛型，Objective-C中有吗？<br>如何实现单例？<br>C#中的拉姆达表达式，Objective-C有吗？<br>等等，等等。</p>
<p>####写Demo练习####<br>实际的练习也是必不可少的。可以通过很多小项目和算法来练习自己对新语言掌握的程度。比如写一个简单的计算器。</p>
<p>经历了以上两部分，我们就能较好的在实际项目中使用新语言了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为一名程序员，我们肯定会在必要的时候学习一门新的编程语言，这个时候好的学习方法会帮助我们节省很多时间，在这里谈谈我的学习方法。</p>
<p>####快速了解语法####<br>我通常会快速了解该门语言的语法，并将其和已学会的语言进行比较。比如我在学习Objective-]]>
    </summary>
    
      <category term="学习" scheme="http://code4cocoa.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://code4cocoa.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VFL布局学习]]></title>
    <link href="http://code4cocoa.com/2014/12/04/VFL%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://code4cocoa.com/2014/12/04/VFL布局学习/</id>
    <published>2014-12-04T15:17:14.000Z</published>
    <updated>2015-12-05T07:39:26.000Z</updated>
    <content type="html"><![CDATA[<p>随着iPhone6及iPhone6+的发布，适配大屏幕也提上了日程。有些童鞋习惯用xib配合iOS6时出现的autolayout进行界面的布局，但是我个人觉得xib实在是有点难用，特别是在macbook的小屏幕上，觉得xib要配一个大屏幕用起来才爽。还有就是用过Visual Studio的可视化编程后，始终觉得xib的易用性不够好。大屏幕又不得不适配，怎么办呢，如果像以前那样算坐标的话倒是也行，但毕竟比较繁琐，又不想用xib，那就只好用<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage/VisualFormatLanguage.html" target="_blank" rel="external">Visual Format Language</a>。</p>
<p>初看VFL，肯定觉得莫名奇妙，给我的感觉就像第一次看到正则表达式的时候一样(个人以为VFL可比正则表达式简单多了)。不过VFL的符号比较少且简单，用2-3次估计就都记住了，大家可以看看上面官方文档的链接。我在这里简单介绍一下常用的符号表示的意思(我会用<strong>方引号(「」)</strong>将符号括起来)：</p>
<p><strong>「V:」</strong>或<strong>「H:」</strong>分别表示垂直方向和水平方向。</p>
<p><strong>「|」</strong>表示父视图。</p>
<p><strong>「[loginButton]」</strong>表示一个名叫loginButton的视图</p>
<p><strong>「H:|-10-[loginButton]-10-|」</strong> 表示 <strong>loginButton在水平方向左边距离父视图10，右边距离父视图也是10</strong>。</p>
<p><strong>「H:|-15-[buttonOne(80)]-5-[buttonTwo(90)]」</strong> 表示<strong>buttonOne在水平方向左边距离父视图是15，本身宽度是80，右边与buttonTwo的距离为5，buttonTwo的宽度为90</strong>。</p>
<p>以上这些就是常用的符号，掌握着几种最基本的也足够我们进行大部分的界面布局了。<br>接下来我们简单写一个例子。我们假设大家都是有一定iOS编程基础的童鞋，所以怎么创建Single View Application这种事情就不罗嗦了，我们假设大家已经创建好了，接下来的我们将在View上添加一个Button，并用VFL来控制它的位置和大小。</p>
<p><pre><code><br>//我们在这里创建一个Buton<br>-(void)viewDidLoad<br>{<br>[super viewDidLoad];<br>UIButton* button=[[UIButton alloc] init];</code></pre></p>
<p>//切记在这里一定要将该属性设置为NO，否则View<br>//会按照以往的autoresizingMask进行计算。<br>button.translatesAutoresizingMaskIntoConstraints=NO;</p>
<p>[button setTitle:@”测试” forState:UIControlStateNormal];<br>[self.view addSubview:button];<br>//当然，就这么执行程序是没有任何效果的，我们看不到Button出现在View上。</p>
<p>//用于存储约束<br>NSMutableArray *constraints = [NSMutableArray array];</p>
<p>//添加按钮的水平约束，意思是该按钮宽度90，距离父控件右边30。<br>[constraints<br>addObjectsFromArray:<br>[NSLayoutConstraint<br>constraintsWithVisualFormat:@”H:[button(90)]-30-|”<br>options:0<br>metrics:nil<br>views:NSDictionaryOfVariableBindings(<br>button)]];</p>
<p>//添加按钮的垂直约束，意思是该按钮高度40，距离父控件上边100。<br>[constraints<br>addObjectsFromArray:<br>[NSLayoutConstraint<br>constraintsWithVisualFormat:@”V:|-100-[button(40)]”<br>options:0<br>metrics:nil<br>views:NSDictionaryOfVariableBindings(<br>button)]];</p>
<p>//将约束添加到View中。<br>[self.view addConstraints:constraints];<br>}<br><br>看完例子有木有觉得很简单，很有趣？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着iPhone6及iPhone6+的发布，适配大屏幕也提上了日程。有些童鞋习惯用xib配合iOS6时出现的autolayout进行界面的布局，但是我个人觉得xib实在是有点难用，特别是在macbook的小屏幕上，觉得xib要配一个大屏幕用起来才爽。还有就是用过Visual]]>
    </summary>
    
      <category term="VFL" scheme="http://code4cocoa.com/tags/VFL/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
      <category term="自动布局" scheme="http://code4cocoa.com/tags/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[梯子推荐]]></title>
    <link href="http://code4cocoa.com/2014/12/04/%E6%A2%AF%E5%AD%90%E6%8E%A8%E8%8D%90/"/>
    <id>http://code4cocoa.com/2014/12/04/梯子推荐/</id>
    <published>2014-12-04T07:10:04.000Z</published>
    <updated>2015-12-04T07:14:28.000Z</updated>
    <content type="html"><![CDATA[<p>作为IT从业者，好用的梯子可以说是必备之物。在这里我推荐<a href="http://honx.in/i/U6jd04Ko13KmmIiD" target="_blank" rel="external">红杏</a>。<br>它是一款Chrome、FireFox插件，相较于VPN等，使用简单方便，价格便宜(每月10元)，且不限流量。唯一的缺点是只能在浏览器上使用，当然他们的客服说目前正在开发不依赖浏览器的版本，很值得期待。</p>
<p>PS:我一般是配合VPN使用的。只是在网上查查资料的话就用红杏足矣。如果涉及本地应用需要梯子，我用的是<a href="https://www.123ssh.net/" target="_blank" rel="external">123SSH</a>，价格比红杏略贵，配合GoAgent可以实现按规则翻墙，就是配置起来还是比较麻烦，不如红杏那么简单易用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为IT从业者，好用的梯子可以说是必备之物。在这里我推荐<a href="http://honx.in/i/U6jd04Ko13KmmIiD" target="_blank" rel="external">红杏</a>。<br>它是一款Chrome、FireFox插件，相较]]>
    </summary>
    
      <category term="GFW" scheme="http://code4cocoa.com/tags/GFW/"/>
    
      <category term="VPN" scheme="http://code4cocoa.com/tags/VPN/"/>
    
      <category term="翻墙" scheme="http://code4cocoa.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记四]]></title>
    <link href="http://code4cocoa.com/2014/11/19/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>http://code4cocoa.com/2014/11/19/Swift学习笔记四/</id>
    <published>2014-11-19T13:42:23.000Z</published>
    <updated>2015-12-07T09:02:50.000Z</updated>
    <content type="html"><![CDATA[<p>Swift中的集合类型，数组和字典与Objective-C中相比，最大的不同就是<strong>类型安全</strong>。例如：如果我们创建了一个Int值类型的数组，我们就不能往其中插入任何不是Int类型的数据。</p>
<pre><code>
//我们创建一个人员数组。
var employees : [String] = ["Jack","Mike"]
</code></pre>
实际上上面的数组我们利用Swift的推断特性，还可以写成这样
<pre><code>
var employees = ["Jack","Mike"]
</code></pre>
<pre><code>
//创建一个空数组
var array=Array<string>()
//或者
var array=[String]
</string></code></pre>

<p>count属性用于后去数组的Item数量。<br>isEmpty属性可以快速的检测count是否为0。<br>append方法可以用于追加新的数据项。<br>for-in用于遍历数组。<br>我们可以使用+操作符来组合两个相同类型的数组。</p>
<p>字典在Swift中也是类型安全的，字典使用Dictionary<keytype, valuetype="">定义,其中KeyType是字典中键的数据类型，ValueType是字典中对应于这些键所存储值的数据类型。</keytype,></p>
<p>KeyType的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如String，Int， Double和Bool）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。</p>
<pre><code>
//定义机场的缩写和全称
var airports: Dictionary<string, string=""> = ["TYO": "Tokyo", "DUB": "Dublin"]
//或者这样定义
var airports= ["TYO": "Tokyo", "DUB": "Dublin"]
</string,></code></pre>

<p><strong>如果集合遍历被定义为var，那么就是可变的。数组中的长度和其中的元素可以被修改，字典的长度和其中的元素也可以被修改。如果被定义为let，则不允许被修改。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift中的集合类型，数组和字典与Objective-C中相比，最大的不同就是<strong>类型安全</strong>。例如：如果我们创建了一个Int值类型的数组，我们就不能往其中插入任何不是Int类型的数据。</p>
<pre><code>
//我们创建一个人员数组。]]>
    </summary>
    
      <category term="Swift" scheme="http://code4cocoa.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[手势的使用]]></title>
    <link href="http://code4cocoa.com/2014/11/19/%E6%89%8B%E5%8A%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://code4cocoa.com/2014/11/19/手势的使用/</id>
    <published>2014-11-19T10:02:16.000Z</published>
    <updated>2015-12-07T09:01:50.000Z</updated>
    <content type="html"><![CDATA[<p>iOS让人着迷的地方之一，就是无与伦比的手势操作。记得大学时第一次看到双指缩放图片时的惊奇，以至于玩图片库可以玩一节课。在这里我收集整理一下手势的用法。</p>
<p>iOS中，与手势相关的类继承自UIKit中的UIGestureRecognizer类，它是一个<a href="https://en.wikipedia.org/wiki/Abstract_type" target="_blank" rel="external">抽象类</a>，定义了所有手势的基本行为，iOS支持的所有基础手势如下：</p>
<ul>
<li>UITapGestureRecognizer 拍击，任意次数的拍击。</li>
<li>UIPinchGestureRecognizer 向里或向外捏，用于缩放。</li>
<li>UIPanGestureRecognizer 拖拽。</li>
<li>UISwipeGestureRecognizer 任意方法的擦碰。</li>
<li>UIRotationGestureRecognizer 旋转，比如旋转照片。</li>
<li>UILongPressGestureRecognizer 长按。</li>
</ul>
<p>####UITapGestureRecognizer####<br>这是我个人用得比较多的一个手势，主要是给没有点击事件的控件添加单击事件。比如给UIImageView添加单击功能。</p>
<script src="https://gist.github.com/yuxiangq/b56b55a42585a8a18d0f.js"></script>

<p><strong>setNumberOfTapsRequired</strong> 方法设置拍击几次响应。<br><strong>setNumberOfTouchesRequired</strong> 方法设置几个手指拍击。</p>
<p>####UILongPressGestureRecognizer####<br>长按手势就我个人而言，用得次多的手势。主要用于一些隐藏得，有明确指向目标的逻辑触发。</p>
<script src="https://gist.github.com/yuxiangq/4dfeebc687b459b629bc.js"></script>

<p>####UISwipeGestureRecognizer和UIPanGestureRecognizer####<br>擦碰手势和拖动手势有很相似的地方，所以有些童鞋弄得不是很清楚，所以放到一起将。<br>擦碰手势，分上下左右四个方向，它只是侦测你手指在屏幕上轻扫的方向，然后进行一些功能。</p>
<script src="https://gist.github.com/yuxiangq/ad389e9c32eaec44fc78.js"></script>

<p>拖动手势UIPanGestureRecognizer与擦碰手势有个最大的区别是，拖动手势手指始终要在屏幕上。而擦碰手势，手指最后是离开屏幕的。</p>
<script src="https://gist.github.com/yuxiangq/f166cf725ce21cb78f95.js"></script>
-(CGPoint)translationInView:(UIView *)view 方法返回拖动的距离，传入的view是参照物。
-(CGPoint)velocityInView:(UIView *)view 方法返回拖动的速度，传入的view是参照物。

####UIPinchGestureRecognizer和UIRotationGestureRecognizer####
这两个手势我都没有使用过o(╯□╰)o
<script src="https://gist.github.com/yuxiangq/af83a2477e014f5f79b9.js"></script>
<script src="https://gist.github.com/yuxiangq/de8a69b4873c4b02be32.js"></script>















]]></content>
    <summary type="html">
    <![CDATA[<p>iOS让人着迷的地方之一，就是无与伦比的手势操作。记得大学时第一次看到双指缩放图片时的惊奇，以至于玩图片库可以玩一节课。在这里我收集整理一下手势的用法。</p>
<p>iOS中，与手势相关的类继承自UIKit中的UIGestureRecognizer类，它是一个<a hre]]>
    </summary>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
      <category term="手势" scheme="http://code4cocoa.com/tags/%E6%89%8B%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记三]]></title>
    <link href="http://code4cocoa.com/2014/10/26/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://code4cocoa.com/2014/10/26/Swift学习笔记三/</id>
    <published>2014-10-26T12:00:06.000Z</published>
    <updated>2015-12-07T09:00:50.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分主要了解运算符，因为大部分编程语言的运算符都相似，所以在这里我只记录有Swift特色的运算符。</p>
<p>###区间运算符###<br>Swift 提供了两个方便表达一个区间的值的运算符</p>
<p>####闭区间运算符####<br>闭区间运算符（a…b）定义一个包含从a到b(包括a和b)的所有值的区间，b必须大于a。 ‌ 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在for-in循环中</p>
<pre><code>
for index in 1...5  {
println("\(index) * 5 = \(index * 5)")
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
</code></pre>
####半开区间运算符####
半开区间（a..<b）定义一个从a到b但不包括b的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。="" <pre=""><code>
for index in 1...< 5  {
println("\(index) * 5 = \(index * 5)")
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
</code>

<p>###空合运算符###<br>空合运算符(a ?? b)将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b.这个运算符有两个条件</p>
<ul>
<li>表达式a必须是Optional类型</li>
<li>默认值b的类型必须要和a存储值的类型保持一致</li>
</ul>
<pre><code>
let defaultColorName = "red"
var userDefinedColorName:String?   //默认值为nil
var colorNameToUse = userDefinedColorName ?? defaultColorName
//userDefinedColorName的值为空 ，所以colorNameToUse的值为red
</code></pre>

<p>实际上该运算符我在C#中早已接触过，确实是非常好用，配合可空类型，使代码相当优雅。</p>
</b）定义一个从a到b但不包括b的区间。>]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分主要了解运算符，因为大部分编程语言的运算符都相似，所以在这里我只记录有Swift特色的运算符。</p>
<p>###区间运算符###<br>Swift 提供了两个方便表达一个区间的值的运算符</p>
<p>####闭区间运算符####<br>闭区间运算符（a…b）定]]>
    </summary>
    
      <category term="Swift" scheme="http://code4cocoa.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift学习笔记二]]></title>
    <link href="http://code4cocoa.com/2014/10/23/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://code4cocoa.com/2014/10/23/Swift学习笔记二/</id>
    <published>2014-10-23T15:10:01.000Z</published>
    <updated>2015-12-07T08:55:37.000Z</updated>
    <content type="html"><![CDATA[<p>Swift是一门类型安全的语言，Swift中包含的基础数据类型有以下7种</p>
<ul>
<li>Int 整型，长度与当前平台的原生字长相同。在32位平台上，Int和Int32相同；在64位平台上和Int64相同。</li>
<li>Double 浮点型，表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float 浮点型，表示32位浮点数。精度要求不高的话可以使用此类型。</li>
<li>Bool 布尔型</li>
<li>String 字符串</li>
<li>Array 数组集合</li>
<li>Dictinary 词典集合</li>
</ul>
<p>Swift中还包含Objective-C中不包含的高阶数据类型比如元组(Tuple)，用它可以很方便的通过一个函数返回多个值。</p>
<p><strong>声明常量和变量</strong></p>
<pre><code>
//常量
let a=0
//变量
var b=1
</code></pre>

<p><strong>类型标注</strong></p>
<pre><code>
let num:Int = 1
let str:String = "test"
</code></pre>
*注意：*
*Swift支持类型推断，可以不用进行标注，Swift会根据你初始化该变量或常量使用的值，推断出类型。*

**Hello world**
<pre><code>
println(“hello world”)
</code></pre>
println是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，println将会输出内容到“console”面板上。(另一种函数叫print，唯一区别是在输出内容最后不会换行。)

与 Cocoa 里的NSLog函数类似的是，println函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。

Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：
<pre><code>
let str="hello world"
println("this is \(str)") //this is hello world
</code></pre>

<p><strong>类型安全和类型推断</strong></p>
<p>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。</p>
<p>当你定义变量或常量，如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p><strong>类型别名</strong></p>
<p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。</p>
<pre><code>
typealias MyInt=Int
var a:MyInt=0
</code></pre>

<p><strong>元组</strong></p>
<p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，(404, “Not Found”)是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个404 Not Found状态码。</p>
<pre><code>
let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")
</code></pre>

<p>并且可以很方便的将元组的内容分解</p>
<p><pre><code><br>let (statusCode, statusMessage) = http404Error<br>println(“The status code is (statusCode)”)<br>// 输出 “The status code is 404”<br>println(“The status message is (statusMessage)”)<br>// 输出 “The status message is Not Found”<br></code></pre><br>你可以在定义元组的时候给单个元素命名，给元组中的元素命名后，你可以通过名字来获取这些元素的值</p>
<p><pre><code><br>let http200Status = (statusCode: 200, description: “OK”)<br>println(“The status code is (http200Status.statusCode)”)<br>// 输出 “The status code is 200”<br>println(“The status message is (http200Status.description)”)<br>// 输出 “The status message is OK”<br></code></pre><br><em>注意：</em><br><em>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。</em></p>
<p><strong>可选类型(可空类型)</strong><br>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示：</p>
<ul>
<li>有值，等于 x</li>
</ul>
<p>或者</p>
<ul>
<li>没有值</li>
</ul>
<p>这个特性类似于C#中的可空类型，甚至表示方式都近似。<br>在我们与数据库交互的时候，可空值是非常重要的。因为数据库中的所有类型都是允许null的。</p>
<p><em>注意：</em><br><em>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</em></p>
<p>来看一个例子。Swift 的String类型有一个叫做toInt的方法，作用是将一个String值转换成一个Int值。然而，并不是所有的字符串都可以转换成一个整数。字符串”123”可以被转换成数字123，但是字符串”hello, world”不行。</p>
<p>下面的例子使用toInt方法来尝试将一个String转换成Int</p>
<p><pre><code><br>let possibleNumber = “123”<br>let convertedNumber = possibleNumber.toInt()<br>// convertedNumber 被推测为类型 “Int?”， 或者类型 “optional Int”<br></code></pre><br>因为toInt方法可能会失败，所以它返回一个可选类型（optional）Int，而不是一个Int。一个可选的Int被写作Int?而不是Int。问号暗示包含的值是可选类型，也就是说可能包含Int值也可能不包含值。（不能包含其他任何值比如Bool值或者String值。只能是Int或者什么都没有。）</p>
<p><strong>if语句及强制解析</strong><br>可以使用if语句来判断一个可空值是否包含值。如果有值，则可通过在可空值变量后添加「感叹号」的方式获取该值，比如</p>
<p><pre><code><br>if convertedNumber != nil {<br>println(“(possibleNumber) has an integer value of (convertedNumber!)”)<br>} else {<br>println(“(possibleNumber) could not be converted to an integer”)<br>}<br></code></pre><br><em>注意：</em><br><em>使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。</em></p>
<p><strong>可选绑定</strong><br>使用可选绑定重写上面的例子为</p>
<p><pre><code><br>if let actualNumber = possibleNumber.toInt() {<br>println(“(possibleNumber) has an integer value of (actualNumber)”)<br>} else {<br>println(“(possibleNumber) could not be converted to an integer”)<br>}<br>// 输出 “123 has an integer value of 123”<br></code></pre><br>这段代码可以被理解为：</p>
<p>“如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作actualNumber的值，你可以改成if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p><em>注意：</em><br><em>Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，nil是一个指向不存在对象的指针。在 Swift 中，nil不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为nil，不只是对象类型。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift是一门类型安全的语言，Swift中包含的基础数据类型有以下7种</p>
<ul>
<li>Int 整型，长度与当前平台的原生字长相同。在32位平台上，Int和Int32相同；在64位平台上和Int64相同。</li>
<li>Double 浮点型，表示64位浮点数]]>
    </summary>
    
      <category term="Swift" scheme="http://code4cocoa.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://code4cocoa.com/tags/iOS/"/>
    
  </entry>
  
</feed>
