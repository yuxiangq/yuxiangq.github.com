<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>专业主义</title>
      <link href="/2019/10/04/%E4%B8%93%E4%B8%9A%E4%B8%BB%E4%B9%89/"/>
      <url>/2019/10/04/%E4%B8%93%E4%B8%9A%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p><code>专家的词源本是“profess”，意思是“向上帝发誓，以此为职业”。</code></p><p>《专业主义》是管理大师大前研一先生的著作，在这本书中对“专家”进行了定义。并就优秀的专家应当具备一些什么样的素质，大前研一先生在书中给出了自己的答案。</p><h2 id="你够专业吗？"><a href="#你够专业吗？" class="headerlink" title="你够专业吗？"></a>你够专业吗？</h2><p>作为面试官的时候，我们有时会说“这个候选人很不专业”。和客户沟通的时候，我们也时常说“这个客户太不专业”。尤其对于大部分工程师来说，当和一个“不专业”的人沟通时，通常会比较尴尬。</p><p>曾经和渠道经理一起参加代理商会议，当代理商知道我是工程师时，我的“噩梦”就开始了。<br><code>“咱们产品还在用SQL，太过时了，现在人家都用MySQL”、“你们应该用Java，点恩一体是微软的东西，不行”、“我以前也是学编程的，你们那个产品功能那么简单，还卖那么贵，太赚钱了”、“还是要做app，以后电脑就淘汰了，我们都只用手机”、“新版本的IE6支持你们要搞一下，这个不难嘛”、“小程序出来后app就没用了”</code></p><p>目前为止，我们对专业的认知更多的停留在技能层面。如果一个人掌握了某个领域的相关技能，我们会说这个人是某个领域的专家，或者说他在某个领域很专业。人们对专家普遍的定义为：</p><ul><li>凭借专门的知识和技能获得报酬的人。</li><li>不仅是在公司内部，从公司外部来看，也具备第一线通用的专业知识和实际业务能力。</li><li>能够发挥应有作用的人。</li><li>对着自己的工作怀着理想和自豪感，并且不断努力。</li></ul><p>但大前研一先生认为这都是不准确的。几乎所有针对专家的定义都把焦点对准知识和技能，而忽略了其他素质。但作为专家有一些素质也是比不可少的。</p><ul><li><strong>考虑顾客的利益</strong>，应当铭记，从事任何工作都要首先确定自己的顾客。</li><li><strong>持续学习的意愿</strong>，绝不认为自己的本领是绝对的，而是准备花费一生的时间磨砺自己，并且乐此不疲</li><li><strong>保有好奇心</strong>，不怠慢自己的智慧，积极的挑战新事物。</li></ul><p>在此基础上，大前研一先生还总结了专家应具有的能力体系。</p><h2 id="先见能力"><a href="#先见能力" class="headerlink" title="先见能力"></a>先见能力</h2><p>先见能力，是能够看清别人看不到的事物，不拘泥于过往经验，快速洞察机会的能力。</p><p><code>新的“商业竞争领域”如台风般毫不留情地摧毁着旧的经济世界。让我们一筹莫展的是，我们无法用眼睛看清这块“商业竞争领域”，也感受不到它扑面而来的猛烈势头。这正是“看不见的新大陆”。</code></p><p>大前研一先生总结了拥有先见能力的特质：</p><ul><li><strong>怀疑一切</strong>，对常识和固有的知识提出质疑。</li><li><strong>享受变化</strong>，对于未知领域带来的变化，应当积极拥抱。</li><li><strong>不怕失败</strong>，失败不可怕，即使失败也要发起挑战。</li><li><strong>执着探索</strong>，执着的精神是我们的护身符。</li></ul><h2 id="构思能力"><a href="#构思能力" class="headerlink" title="构思能力"></a>构思能力</h2><p><code>一些企业尽管富于先见性，但由于没有冷静地思考如何走向成功而被淘汰，在市场中销声匿迹，这样的实例不胜枚举。</code></p><p>我们常说“想得太多，做得太少”，头脑风暴搞出几个不错的idea，最后一个也没有落实。</p><p>先见能力能确保我们比别人更早的看到新的市场，但只有这样是远远不够的。如何开拓市场，确保企业能在新的事业领域收获果实，这就是构思能力。</p><p>为了使预见到的机会和事业不至于变为空想，我们必须有自我否定的勇气。</p><p>比如胶卷时代的一方霸主柯达，它本质上是一家化工公司，拥有全线银盐影像产品核心技术。但这也为它在到来的数码时代，套上了枷锁。</p><p>事实上柯达是数码相机的先驱，1975年的时候柯达公司的史蒂文 · 萨逊开发了第一台数码相机的原型。但那个时候技术不成熟，所以没有大面积普及，但随着20世纪90年代以来，数码相机在技术上的不断改进，价格越来越低，情况就变得微妙了起来。</p><p>可以说在数码相机初崛起的时代，柯达的专家们拘泥于过去的成功，无法全面的投入到新时代的竞争中去。同时也误判了数码相机普及的规模和速度，最终内忧外患之下，业绩一落千丈。</p><p><code>自我变革没有止境，它通过由先见到构思、再由构思到先见的不断循环得以实现。</code></p><h2 id="讨论的能力"><a href="#讨论的能力" class="headerlink" title="讨论的能力"></a>讨论的能力</h2><p>讨论和开会一样，作为职场人士我们都习以为常。初看的时候，会惊异于大前研一先生把讨论的能力作为专家能力体系中的一项。看完后我认为可以将讨论的能力理解为沟通能力，即如何更好的倾听别人的发言、说服别人等。</p><p>在ThoughtWorks团队，我们有很多机会进行讨论，IPM、Retro、Code Review。讨论的目的通常是为了就某些问题、分歧达成一致。我们在讨论上要做的事情有提问、倾听、说服。</p><p>一个好的问题应当是非常明确的，对于参与讨论的人来说，他们应该很容易的从问题中了解我们的主张、目的。</p><p>倾听的时候，我们应当集中注意力去关注来自各方的观点和意见，不要受“发言者”是谁的影响。养成关注“说的是什么”的习惯至关重要。</p><p>说服别人的关键在于能否有效地展示出作为发言根据的事实。谈话技巧的高明固然重要，但基于事实的谈话更能令人信服。</p><h2 id="适应矛盾的能力"><a href="#适应矛盾的能力" class="headerlink" title="适应矛盾的能力"></a>适应矛盾的能力</h2><p><code>经营中也包含着相互矛盾的事物，或者说同时需要解决两方面的问题。这是仅凭逻辑而无法认清的。</code></p><p>对于一个问题，可能会有多个答案，我们需要辩证的去看待多个答案，弱化对唯一答案的执着。每一个答案都会有适用的场景，我们不能为了找出最好的答案而否定其他答案，这是一个陷阱。</p><p>就如大前研一先生书中所提到的集权与分权、全球化与本土化、管理上的自由与统率之间的关系。并且提出我们要将左脑（理论）与右脑（直觉）的能力结合起来，这样才是优秀的专家。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库存需求预测基础模型</title>
      <link href="/2019/07/30/%E5%BA%93%E5%AD%98%E9%9C%80%E6%B1%82%E9%A2%84%E6%B5%8B%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/07/30/%E5%BA%93%E5%AD%98%E9%9C%80%E6%B1%82%E9%A2%84%E6%B5%8B%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>库存预测</strong>是库存管理中的重要一环，也是是库存计划的基石。关于库存预测，我们首先要了解的是：</p><p>“预测”不是“预言”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预测，是研究和预估未来将会发生的事件及结果。预测类似预言、预知、占卜，前者可能是可供检测的科学方法，后者则常常无法证伪。</span><br></pre></td></tr></table></figure><p>我们需要基于已有的历史数据，推断出未来某个时间点或时间范围的数据。推断的方法，经过人们不断的归纳总结，最终变为目前我们熟知的预测模型。</p><p><strong>库存预测</strong>通常是在历史数据的基础上，找到拟合度最高的预测模型。但现在的业务通常都受多方面因素的影响，我们在选择预测模型的时候要考虑一定的灵活性。灵活度有保证的情况下，必然会影响预测的准度，这是需要我们来平衡的问题。</p><h1 id="幼稚预测"><a href="#幼稚预测" class="headerlink" title="幼稚预测"></a>幼稚预测</h1><p>顾名思义，这是一种“不预测”的预测方式，它的方式是<strong>用上一次的需求值，作为这一次的预测值</strong>。</p><h1 id="移动平均"><a href="#移动平均" class="headerlink" title="移动平均"></a>移动平均</h1><h1 id="指数平滑"><a href="#指数平滑" class="headerlink" title="指数平滑"></a>指数平滑</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库存管理之成本算法</title>
      <link href="/2019/06/26/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E6%88%90%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/26/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E6%88%90%E6%9C%AC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>库存管理</strong>，是指企业对尚未售出货物与原材料的管理。它是企业运营需求上的重要一环，也是管理者极为关心的课题。比如，依照著名的摩尔定律，计算机运算能力每18个月会加倍，故导致科技产品的生命周期过短，一项新产品的销售热潮经常仅在3~9个月。在销售热潮期间，如果库存不足的话，会无法满足客户需求，流失部分订单。如果库存过多的话，则会积压公司资金。</p><p><strong>成本</strong>，指已销售商品的进价。由于商品的进价不会固定维持在一个价格，可能因为进货渠道的改变、付款方式的改变、商品原材料价格波动等等导致变化。销售商品的时候，我们需要一些方式来确定一个适当的进货价格，以计算商品销售成本和确定库存价值，据此核算商品销售损益，用以反映企业的经营状况。不同的成本算法还会影响企业的税收负担、现金流等。常见的成本算法有四种：加权平均、移动加权平均、先进先出、后进先出。</p><h2 id="加权平均"><a href="#加权平均" class="headerlink" title="加权平均"></a>加权平均</h2><p><strong>加权平均</strong> 是以采购历史中的商品采购均价作为商品成本，最后以 <strong>商品采购均价</strong> 乘以销售数量得到销售成本，乘以库存数量得到库存成本，其计算方式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">商品采购均价  =（期初库存金额 + 本期购入金额）/（期初库存数量 + 本期购入数量）</span><br><span class="line">库存成本 = 商品采购均价 <span class="symbol">*</span> 库存数量</span><br><span class="line">商品销售成本 = 商品采购均价 <span class="symbol">*</span> 销售数量</span><br><span class="line"></span><br><span class="line">|<span class="string">日期 </span>|<span class="string">操作</span>|<span class="string">商品</span>|<span class="string">金额</span>|<span class="string">数量</span>|</span><br><span class="line">|<span class="string"> :--- </span>|<span class="string"> :--- </span>|<span class="string"> :--- </span>|<span class="string"> :--- </span>|<span class="string"> :--- </span>|</span><br><span class="line">|<span class="string">01-02</span>|<span class="string">购买</span>|<span class="string">A</span>|<span class="string">1</span>|<span class="string">10</span>|</span><br><span class="line">|<span class="string">01-05</span>|<span class="string">购买</span>|<span class="string">A</span>|<span class="string">1</span>|<span class="string">5</span>|</span><br><span class="line">|<span class="string">01-06</span>|<span class="string">销售</span>|<span class="string">A</span>|<span class="string">2</span>|<span class="string">5</span>|</span><br><span class="line">|<span class="string">01-10</span>|<span class="string">购买</span>|<span class="string">A</span>|<span class="string">0.5</span>|<span class="string">10</span>|</span><br><span class="line">|<span class="string">01-14</span>|<span class="string">销售</span>|<span class="string">A</span>|<span class="string">2</span>|<span class="string">10</span>|</span><br><span class="line"></span><br><span class="line">从以上流水我们可以看出进行了三次采购操作，则商品的采购均价为 0.8 = ( 1 <span class="symbol">*</span> 10  + 1 <span class="symbol">*</span> 5  + 0.5 <span class="symbol">*</span> 10 ) / ( 10 + 5  + 10 ) </span><br><span class="line">库存成本我们通过流水可知一共购买了25个A商品，销售了15个A商品，剩余10个，则库存成本为 8 = 0.8 <span class="symbol">*</span> 10</span><br><span class="line">商品销售成本为 12 = 0.8 <span class="symbol">*</span> 15 </span><br><span class="line">商品销售利润为 18 = 2 <span class="symbol">*</span> 15 - 0.8 <span class="symbol">*</span> 15</span><br></pre></td></tr></table></figure><p>在使用 <strong>加权平均</strong> 的情况下，如果商品的采购金额经常发生变化，则成本的计算会受到历史采购的影响，不能较好真实的反映当前情况，从而影响销售利润和库存成本的计算。</p><h2 id="移动加权平均"><a href="#移动加权平均" class="headerlink" title="移动加权平均"></a>移动加权平均</h2><p><strong>移动加权平均</strong> 会记录每次库存发生变化后的成本，可以准确计算单笔销售的利润，其计算方式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">日期 </span>|<span class="string">操作</span>|<span class="string">商品</span>|<span class="string">金额</span>|<span class="string">数量</span>|</span><br><span class="line">|<span class="string"> :--- </span>|<span class="string"> :--- </span>|<span class="string"> :--- </span>|<span class="string"> :--- </span>|<span class="string"> :--- </span>|</span><br><span class="line">|<span class="string">01-02</span>|<span class="string">购买</span>|<span class="string">A</span>|<span class="string">1</span>|<span class="string">10</span>|</span><br><span class="line">|<span class="string">01-05</span>|<span class="string">购买</span>|<span class="string">A</span>|<span class="string">1</span>|<span class="string">5</span>|</span><br><span class="line">|<span class="string">01-06</span>|<span class="string">销售</span>|<span class="string">A</span>|<span class="string">2</span>|<span class="string">5</span>|</span><br><span class="line">|<span class="string">01-10</span>|<span class="string">购买</span>|<span class="string">A</span>|<span class="string">0.5</span>|<span class="string">10</span>|</span><br><span class="line">|<span class="string">01-14</span>|<span class="string">销售</span>|<span class="string">A</span>|<span class="string">2</span>|<span class="string">10</span>|</span><br><span class="line"></span><br><span class="line">使用移动加权平均法的情况下</span><br><span class="line">1月2号、1月5号连续同采购价格采购15个A商品后，库存成本为 1 <span class="symbol">*</span> 10 + 1 <span class="symbol">*</span> 5 = 15，成本单价为1</span><br><span class="line"></span><br><span class="line">1月6号销售5个A商品， 商品销售成本为 1 <span class="symbol">*</span> 5 = 5 商品销售利润为 2 <span class="symbol">*</span> 5 - 1 <span class="symbol">*</span> 5 = 5，库存成本变为 1 <span class="symbol">*</span> 10 = 10</span><br><span class="line"></span><br><span class="line">1月10号以0.5的采购价格，采购了10个A商品，这时库存成本为 1 <span class="symbol">*</span> 10 + 0.5 <span class="symbol">*</span> 10 = 15 成本单价为 ( 1 <span class="symbol">*</span> 10 + 0.5 <span class="symbol">*</span> 10 )  / ( 10 + 10 ) = 0.75</span><br><span class="line"></span><br><span class="line">1月14号销售10个A商品，商品销售成本为 0.75 <span class="symbol">*</span> 10 = 7.5 商品销售利润为 2 <span class="symbol">*</span> 10 - 0.75 <span class="symbol">*</span> 10 = 12.5</span><br><span class="line"></span><br><span class="line">综上到期末最终数据为</span><br><span class="line">库存数量为 10 </span><br><span class="line">库存成本为 7.5 = 0.75 <span class="symbol">*</span> 10</span><br><span class="line">商品销售成本为 12.5 = 1 <span class="symbol">*</span> 5 + 0.75 <span class="symbol">*</span> 10</span><br><span class="line">商品销售利润为 17.5 = 5 + 12.5</span><br></pre></td></tr></table></figure><p><strong>移动加权平均</strong> 计算的商品销售成本相对均衡准确，但计算的过程相对复杂。</p><h2 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h2><p><strong>先进先出</strong> 是在销售商品时，将最早购入的商品卖出并将其进价作为成本的一种方法，即先购入先销售。这种方法一般适用于易变质的商品，比如生鲜类商品。其计算方式如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|日期 |操作|商品|金额|数量|</span><br><span class="line">| :--- | :--- | :--- | :--- | :--- |</span><br><span class="line">|01-02|购买|A|1|10|</span><br><span class="line">|01-05|购买|A|1|5|</span><br><span class="line">|01-06|销售|A|2|5|</span><br><span class="line">|01-10|购买|A|0.5|10|</span><br><span class="line">|01-14|销售|A|2|10|</span><br><span class="line"></span><br><span class="line">还是这个流水，在使用先进先出算法情况下我们需要按批次记录商品数量和采购价，所以需要关注的东西较多</span><br><span class="line"></span><br><span class="line">1月2号采购A商品10个，采购单价为1，这批商品记为 批次一</span><br><span class="line"></span><br><span class="line">1月5号采购A商品5个，采购单价为1，这批商品记为 批次二 这时A商品库存数量为<span class="number"> 15 </span>=<span class="number"> 10 </span>[ 批次一 ] +<span class="number"> 5 </span>[ 批次一 ]，库存成本为<span class="number"> 15 </span>=<span class="number"> 1 </span>*<span class="number"> 10 </span>[ 批次一 ] +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ]</span><br><span class="line"></span><br><span class="line">1月6号销售5个A商品，根据先进先出规则，我们应当先销售 批次一  的商品，所以商品销售成本为<span class="number"> 5 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ]，商品销售利润为<span class="number"> 5 </span>=<span class="number"> 2 </span>*<span class="number"> 5 </span>[ 批次一 ] -<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ]，库存数量为<span class="number"> 10 </span>=<span class="number"> 5 </span>[ 批次一 ] +<span class="number"> 5 </span>[ 批次二 ] </span><br><span class="line">库存成本为<span class="number"> 10 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ]  +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ] </span><br><span class="line"> </span><br><span class="line">1月10号采购A商品10个，采购单价为0.5，这批商品记为 批次三  这时A商品库存数量为<span class="number"> 20 </span>=<span class="number"> 5 </span>[ 批次一 ]  +<span class="number"> 5 </span>[ 批次二 ]  +<span class="number"> 10 </span>[ 批次三 ]，库存成本为<span class="number"> 15 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ] +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ] + 0.5 *<span class="number"> 10 </span>[ 批次三 ]</span><br><span class="line"></span><br><span class="line">1月14号销售10个A商品，根据先进先出规则，我们应当先销售 批次一 的商品，但批次一商品库存不够，我们应当按采购顺序销售 批次二 商品，所以商品销售成本为<span class="number"> 10 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ] +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ]</span><br><span class="line">商品销售利润为<span class="number"> 10 </span>= (<span class="number"> 2 </span>*<span class="number"> 5 </span>[ 批次一 ]  +<span class="number"> 2 </span>*<span class="number"> 5 </span>[ 批次二 ] ) - (1 *<span class="number"> 5 </span>[ 批次一 ]  +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ] )</span><br><span class="line"> </span><br><span class="line">综上到期末最终数据为</span><br><span class="line">库存数量为<span class="number"> 10 </span>[批次三]  </span><br><span class="line">库存成本为<span class="number"> 5 </span>= 0.5 *<span class="number"> 10 </span>[ 批次三 ] </span><br><span class="line">商品销售成本为<span class="number"> 15 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ] +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ] +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ]</span><br><span class="line">商品销售利润为<span class="number"> 15 </span>=<span class="number"> 5 </span>+ 10</span><br></pre></td></tr></table></figure><p>使用 <strong>先进先出</strong> 计算的期末库存成本，比较接近市场价。在商品价格波动，且物价普遍处于上涨状态的情况下，先购进的货物其成本相对较低，后购进的货物成本偏高。这样销售的货物价值就低于市场价值，货物销售成本偏低，而期末存货成本偏高。但因货物的售价是按近期市价计算，因而收入较多，销售收入和销售成本不符合配比原则，以此计算出来的利润就偏高。</p><p>利润偏高有利于增强投资人信心，同时不少企业按照利润水平的高低来评价管理人员，并提供一定的奖励。此时管理人员往往乐于采用先进先出法，因为这样做会高估任期内的利润水平，从而多得眼前利益。但偏高的利润也会加重企业的所得税负担，以及向投资人的分红，从而导致企业现金流出量增加。</p><h2 id="后进先出"><a href="#后进先出" class="headerlink" title="后进先出"></a>后进先出</h2><p><strong>后进先出</strong> 和 <strong>先进先出</strong> 正好相反，是将最近购入的商品卖出并将其进价作为成本的一种方式，即后购入先销售。其计算方式如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">|日期 |操作|商品|金额|数量|</span><br><span class="line">| :--- | :--- | :--- | :--- | :--- |</span><br><span class="line">|01-02|购买|A|1|10|</span><br><span class="line">|01-05|购买|A|1|5|</span><br><span class="line">|01-06|销售|A|2|5|</span><br><span class="line">|01-10|购买|A|0.5|10|</span><br><span class="line">|01-14|销售|A|2|10|</span><br><span class="line"></span><br><span class="line">依然是这个流水，后进先出法的计算大体上和先进先出差不多</span><br><span class="line"></span><br><span class="line">1月2号采购A商品10个，采购单价为1，这批商品记为 批次一</span><br><span class="line"></span><br><span class="line">1月5号采购A商品5个，采购单价为1，这批商品记为 批次二 这时A商品库存数量为<span class="number"> 15 </span>=<span class="number"> 10 </span>[ 批次一 ] +<span class="number"> 5 </span>[ 批次一 ]，库存成本为<span class="number"> 15 </span>=<span class="number"> 1 </span>*<span class="number"> 10 </span>[ 批次一 ] +<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次一 ] </span><br><span class="line"></span><br><span class="line">1月6号销售5个A商品，根据后进先出规则，我们应先销售 批次二  的商品，所以商品销售成本为<span class="number"> 5 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ]，商品销售利润为<span class="number"> 5 </span>=<span class="number"> 2 </span>*<span class="number"> 5 </span>[ 批次二 ] -<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ]，库存数量为<span class="number"> 10 </span>[ 批次一 ] </span><br><span class="line"> 库存成本为<span class="number"> 10 </span>=<span class="number"> 1 </span>*<span class="number"> 10 </span>[ 批次一 ] </span><br><span class="line"> </span><br><span class="line">1月10号采购A商品10个，采购单价为0.5，这批商品记为 批次三  这时A商品库存数量为<span class="number"> 20 </span>=<span class="number"> 10 </span>[ 批次一 ]   +<span class="number"> 10 </span>[ 批次三 ]，库存成本为<span class="number"> 15 </span>=<span class="number"> 1 </span>*<span class="number"> 10 </span>[ 批次一 ] + 0.5 *<span class="number"> 10 </span>[ 批次三 ]</span><br><span class="line"></span><br><span class="line">1月14号销售10个A商品，根据后进先出规则，我们应当先销售 批次三 商品，所以商品销售成本为<span class="number"> 5 </span>= 0.5 *<span class="number"> 10 </span>[ 批次三 ]，商品销售利润为<span class="number"> 15 </span>=<span class="number"> 2 </span>*<span class="number"> 10 </span>- 0.5 *<span class="number"> 10 </span>[ 批次三 ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">综上到期末最终数据为</span><br><span class="line">库存数量为<span class="number"> 10 </span>[批次一]  </span><br><span class="line">库存成本为<span class="number"> 10 </span>=<span class="number"> 1 </span>*<span class="number"> 10 </span>[ 批次一 ] </span><br><span class="line">商品销售成本为<span class="number"> 10 </span>=<span class="number"> 1 </span>*<span class="number"> 5 </span>[ 批次二 ] + 0.5 *<span class="number"> 10 </span>[ 批次三 ] </span><br><span class="line">商品销售利润为<span class="number"> 20 </span>=<span class="number"> 5 </span>+ 15</span><br></pre></td></tr></table></figure><p>使用 <strong>后进先出</strong> 法，且物价波动较大的情况下，期末库存成本和市价偏离较大，不能反映当时存货的实际成本。但利润和销售成本和市场接近，较能反映当时的损益水平。对企业来说在预期物价上涨的情况下，采用后进先出可以达到递延所得税支出的目的。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">企业在选择成本算法的时候，首要因素是库存货物的特点及管理要求。在大多数情况下货物都符合 先进先出 的特点，所以 先进先出 的使用比较多一点。</span><br><span class="line"> </span><br><span class="line">第二方面的因素就是对企业财务的影响，不同的成本算法会直接影响期末库存价值的确定和销售成本的计算，进而对企业的利润、税收负担、现金流量、财务比率等产生影响。在物价持续上涨的情况下，采用 后进先进 会导致较低的 期末库存、销售毛利、所得税和净收益额；而采用 先进先出 其结果恰好相反。如果物价持续下跌，则会得出相反的结论。不论物价如何变动，采用 平均法 <span class="comment">( 包括 加权平均 和 移动平均 )</span> 核算的结果，总是介于 先进先出 和 后进先出 之间。但是，上述存成本算法对企业的一般财务影响又会因企业自身的特点及其所处的不同时期而产生差异。例如：周转很快、库存积压很少，则 后进先出 的优势也不会充分显示。</span><br><span class="line"> </span><br><span class="line">第三面的因素则是对企业经营管理和业绩评价的影响。由于库存货物的管理一般是 先进先出，如采用 后进先出 核算，其结果可能与实际情况不符。不仅如此，后进先出 虽然能够减少所得税，但同时会导致较低的净收益，影响企业经营管理者的经营业绩，影响以净收益为基础的各种奖励和报酬。因此，从内部管理及业绩评价的角度出发，采用 先进先出 比采用 后迸先出 更为合理。此外，在不同企业之间进行经营业绩的比较时，成本算法的不同也将影响业绩评价的正确性。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/2019/01/24/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2019/01/24/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>在18年底的时候做了一个重要的决定 —— 加入一家新公司。<br>很多同事能不理解，已经在一家公司呆了将近8年，为什么还要跳槽？放弃已取得的成就和领导信任，去一家新公司重新开始真的好吗？</p><p>在自己看来，其实去一家新公司并不意味着重新开始。相对而言，得到外部认可的难度比得到内部认可的难度更大。当我们能得到外部优秀公司的认可时，结合自身情况，是可以考虑去一个新的平台尝试的。对我个人而言确实是一个很好的机会，将能够去尝试更多不同的事情，非常有利于自己的职业发展。</p><p>我们在谈到职业规划的时候，通常会认为一个人一定要有足够清晰的职业目标，然后朝着这个方向努力。但很多时候，我们的职业生涯规划也是在渐进明细的。因为人们随着工作年限的增长，对于自己正在从事的工作也会有更清晰的看法，在此基础上对职业生涯的规划肯定和刚工作时候是有差异的。我们需要正视这种差异，只要和原本的初心不是太南辕北辙，那就是没有什么问题的。当然，可能有些人本来不适合做老师，结果还是做了7-8年程序猿，然后大呼要换个行业发展，要去做医生，如果是这种情况，自然是很有问题的了。</p><p>在新的环境也快一个月了，新公司的文化确实有很大的不同，当然这也是很吸引我的地方。很难相信一个公司能做到如此透明，将全球项目的收入情况都对职员公开，我们能很直观的在内部系统上看到各个项目的营收情况。扁平化的管理使每个人都能发出自己的声音。很多在传统企业认为是敏感或得罪公司管理层的信息，我们都能在邮件组中自由讨论。开放的工程师文化确实很令人着迷，每一个人都能去尝试自己感兴趣的东西，做自己的老板。正如公司说的那样:<br>“A community of passionate individuals whose purpose is to revolutionize software design, creation and delivery, while advocating for positive social change.”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的15个架构原则</title>
      <link href="/2018/11/11/%E5%B8%B8%E7%94%A8%E7%9A%8415%E4%B8%AA%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/"/>
      <url>/2018/11/11/%E5%B8%B8%E7%94%A8%E7%9A%8415%E4%B8%AA%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<ul><li>N+1设计。永远不少于两个，通常为三个。</li><li>回滚设计。确保系统可以回滚到以前发布过的任何版本。</li><li>禁用设计。能够关闭任何发布的功能。</li><li>监控设计。在设计阶段就必须考虑监控，而不是在实施完之后补充。</li><li>设计多活数据中心。不要被一个数据中心的解决方案把自己限制住。</li><li>使用成熟的技术。只用确实好用的技术。</li><li>异步设计。只有在绝对必要的时候才进行同步调用。</li><li>无状态系统。只有当业务确实需要的时候，才使用状态。</li><li>水平扩展非垂直升级。永远不要依赖更大、更快的系统。</li><li>设计至少要有两个步骤的前瞻性。在扩展性问题发生前考虑下一步的行动计划。</li><li>非核心则购买。如果不是你擅长的，也提供不了差异化的竞争优势则直接购买。</li><li>使用商品化硬件。在大多数情况下，便宜的是最好的。</li><li>小构建，小发布，快试错。全部研发要小构建，不断迭代，让系统不断成长。</li><li>隔离故障。实现故障隔离设计，通过断路保护避免故障传播和交叉影响。</li><li>自动化。设计和构建自动化的过程。如果机器可以做，就不要依赖于人。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单机软件和SaaS的反向对接</title>
      <link href="/2018/10/27/%E5%8D%95%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8CSaaS%E7%9A%84%E5%8F%8D%E5%90%91%E5%AF%B9%E6%8E%A5/"/>
      <url>/2018/10/27/%E5%8D%95%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%92%8CSaaS%E7%9A%84%E5%8F%8D%E5%90%91%E5%AF%B9%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>看标题可能比较懵逼，这篇文章到底要说什么。那么我介绍一下项目背景。</p><h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>目前在做的产品是一款SaaS产品，年初的时候因为产品方向变化，需要和公司其他产品进行数据对接，需要对接的产品为公司的PC版产品（这里统一简称H）。</p><p>按照正常设想的数据对接方式，为了实现数据的对接，作为SaaS模式产品，我们需要提供Open API供H使用，由H产品发起数据相关的请求。但公司战略上不允许H产品进行这方面的改动，并且通过沟通也不允许H产品提供Open API。那么这次数据的对接只能完全由我们项目组自己负责处理。</p><h1 id="对接方案"><a href="#对接方案" class="headerlink" title="对接方案"></a>对接方案</h1><p>在团队讨论对接方案的时候，讨论出了两种方案：</p><h2 id="中间件对接"><a href="#中间件对接" class="headerlink" title="中间件对接"></a>中间件对接</h2><p>在PC端安装一个中间件程序，负责向SaaS服务提供数据接口。客户在安装完中间件后，需要将中间件地址（使用内网穿透工具）和SaaS产品的账号绑定，以便我们能找到对应的地址。</p><p>在中间件的设计上我们设想了两种，重中间件和轻中间件。重中间件即中间件直接提供业务接口，并需要判断H产品的版本（H产品活跃的版本非常之多，客户没有升级习惯），保证业务接口能被正常调用。轻中间件则提供数据查询接口，业务处理由服务器端进行，中间件相当于远程的SqlHelper，参数传递为了方便简单处理，都统一为字典。</p><p>重中间件模式首先Pass掉了，因为采用重中间件模式，后期迭代新功能的时候，中间件也需要升级。H产品的客户升级欲望低，再加上前期产品迭代较快，会导致升级平凡，体验不好。所以我们选择了轻中间件模式。但在第一版研发中，还是发现一些问题，并且不能很好的适配云部署的H产品（即将多个客户使用的H产品部署到一台阿阿里云服务器上），所以我们在后续版本使用了数据库直连方式，并使用至今。</p><h2 id="数据库直连"><a href="#数据库直连" class="headerlink" title="数据库直连"></a>数据库直连</h2><p>通过将H产品的数据库直接映射到外网，然后在SaaS产品的Web端和账号进行绑定。这样我们就能访问到客户的H产品数据库，并获取数据。</p><p>这种方式在研发效率上非常高，并且将业务逻辑放在SaaS服务器，避免了产品升级而导致需要升级中间件等问题。但同时也会面临安全问题，大部分客户的数据库密码为弱密码，甚至为空，所以在映射的时候，通常会修改数据库端口号，并修改数据库密码为强密码。</p><p>该方式虽然不用安装中间件，但也需要用花生壳等内网穿透软件将数据库映射到外网。H产品大部分客户使用的数据库为SQL Server 2000精简版，无法通过网络访问。就算是完整版的SQL Server 2000也需要安装SP4补丁才行。整个操作流程还是相当复杂，而且内网穿透软件也是需要付费的，免费版本不稳定。对客户来说使用成本又增加了，那么有没有一种方案能不使用内网穿透软件呢？</p><h2 id="基于中间件的免内网穿透模式"><a href="#基于中间件的免内网穿透模式" class="headerlink" title="基于中间件的免内网穿透模式"></a>基于中间件的免内网穿透模式</h2><p>这个思路基于轻中间件模式，在此基础上让中间件启动之后即和SaaS服务保持长连接，这样服务器端就可以随时向中间件请求数据，并且不用使用内网穿透工具，极大降低了安装操作难度。本质上是需要实现一个双工的RPC。目前成熟的RPC框架还是挺多的，比如Facebook的Thrift，Google的gRPC，网上也有不少基于它们的双向通信方案值得借鉴。大致思路如下图：<br><img src="/media/%E5%AF%B9%E6%8E%A5%E5%85%8D%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%A8%A1%E5%BC%8F.png" alt="对接免内网穿透模式"><br>同时需要对业务服务和Socket服务进行一个拆分，保证他们职责的清晰。Socket服务和中间价本身应是业务无关的，应该保持SqlHelper的角色。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思考：应该引入更多的语言还是更少的语言去设计API呢？</title>
      <link href="/2018/09/24/%E6%80%9D%E8%80%83%EF%BC%9A%E5%BA%94%E8%AF%A5%E5%BC%95%E5%85%A5%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E6%9B%B4%E5%B0%91%E7%9A%84%E8%AF%AD%E8%A8%80%E5%8E%BB%E8%AE%BE%E8%AE%A1API%E5%91%A2%EF%BC%9F/"/>
      <url>/2018/09/24/%E6%80%9D%E8%80%83%EF%BC%9A%E5%BA%94%E8%AF%A5%E5%BC%95%E5%85%A5%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E6%9B%B4%E5%B0%91%E7%9A%84%E8%AF%AD%E8%A8%80%E5%8E%BB%E8%AE%BE%E8%AE%A1API%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在阅读朱赟的书《跃迁 - 从技术到管理的硅谷路径》时，其中一张有这么一道思考题『API的签名是设计语言无关的，那在设计中引入更多的语言还是更少的语言去实现不同的API呢？优点和缺点各是什么？』在这里谈谈我的思考。</p><p>先说优缺点，优点是能根据API的业务不同，去选择特定的语言来优化业务，缺点则是管理成本和风险的增加。</p><p>对于小团队来说，我认为使用更少的语言来实现API是最有利的选择。尽量少的编程语言，能使团队的资源更集中，而且这个时候，较单一的技术栈更方便管理。比如我在刚开始做目前的产品的时候，包括我整个项目就三个研发，我负责iOS和API接口的研发（使用WCF），A负责Android研发，B负责Web研发（ASP.NET MVC）。从主要编程语言来说团队有三种语言C#、Java、Objective-C（暂不算JavaScript吧😆）。这样合作半年后，A也开始负责部分API接口的研发，B也能处理Android的BUG，团队每个人除了自己的主力语言外，同时也掌握了另一门语言，在人员配置上形成了一定的补充。倘若在三人小团队中，不加限制的疯狂引入编程语言，譬如Go、Python、Erlang、C++等等，造成的最终结果是项目难以维护，毕竟能同时掌握这么多语言，并能在项目中不留坑的人实在少见。</p><p>对于大团队，更多的思考应该在合适的技术（语言）用在合适的业务上。同时团队也有足够的人力来维护、扩展项目。所以在技术（语言）的选择上可以相对的大胆一些。并且多技术栈的发展，能有效规避技术栈没落的风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何培养自学能力</title>
      <link href="/2018/08/31/%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E8%87%AA%E5%AD%A6%E8%83%BD%E5%8A%9B/"/>
      <url>/2018/08/31/%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E8%87%AA%E5%AD%A6%E8%83%BD%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，拥有一定的自学能力是必不可少的。那么，如何培养自学能力呢？</p><p><strong>什么是自学能力</strong><br>我的解读是 <em>触及自己知识盲区时，解决问题的能力</em>。譬如我们的一名精通Android开发的工程师（简称A），在A的职业生涯中没有接触过服务器端开发，因某些原因，需要他处理服务器端的问题。这时A同学就需要调用他的自学能力，去解决服务器端的问题。</p><p>自学能力并非完全限制只靠自己，而是动用一切可以动用的力量，最终结果是让自己有能力解决问题、学到知识。譬如可以向牛人请教、谷歌、看视频、看书等等。</p><p><strong>关联的领域</strong><br>对于一名软件工程师，从Java转到PHP，是一种关联领域的自学，而且应当是相对而言比较好上手的。对于软件工程师来说，这应当是一种基本能力，因为工作中常用的技能，更多的就是靠自学而来，而不是Leader或老师教给你的。譬如我在学习一门新语言的时候，会先做好环境，然后看看语法，这时心里就会将其和自己会的几门语言做一下比较，思考他们的异同，这样也容易加深对新知识的印象。</p><p>接下来就是选择用什么来练手，对于编程语言（技术）来说，光看不练肯定是没有什么用的。我们需要弄点实战项目来检验自己，同时帮助我们学习。我个人倾向于选择曾经做个的项目，使用新语言（技术）再实现一遍。这样有两个好处：一、不用纠结于做成什么样，判断标准是现成的；二、可以帮助我们比较两门语言（技术）之间的异同，更好的加深对新语言的理解，并且巩固对老语言的知识，两者在碰撞之下，很容易产生新的感悟。</p><p>在关联领域自学的时候，因为知识相对而言容易贯通，相较于零基础的自学有不少的优势，而且容易找到合适自己的学习方法。倘若作为一名软件工程师，当需要自己去学习一门新语言（技术）的时候，自己却无从下手，那就有必要反思一下自己，有没有花心思在自己的学习能力上了。</p><p><strong>不关联的领域</strong><br>一个没有学过乐器的小伙子，想学吉他，这就是想去学习完全和自己以前经历不沾边的东西。当然很多同学可能觉得去报个吉他学习班不就行了？诚然这是一种方式，并且效率可能还比较高，但老师更多还是充当监督者和引路人的作用，未来进一步的提高还是要依靠自己。</p><p>那么我们如何没有老师的情况下，进入一个全新的领域呢？其实随着互联网的越来越发达，我们很容易找到进入的方法。谷歌一下，立马会出现很多零基础学吉他的方法，还有视频教程。这个时候我们需要大致筛选出自己能懂的且评价较好的，照着练习，很快应该就能找到感觉。</p><p>唯一的问题是我们的热情能保持多久，因为没有老师的监督，我们入门的时间有可能会很长。这会导致我们在学习中得不到正反馈，从而导致热情在某个时间段内，极速的下降，这个时候短期可实现目标的制定，就非常重要了。</p><p>短期目标的确立，能确保我们能在一定时间的努力后，得到积极的正向反馈，以维持我们的热情。比如在学习吉他的时候，我们可以给自己定的目标是，每天爬格子完成后奖励自己一杯肥宅快乐水。每周熟练按一种和弦，熟练后奖励自己一顿大餐等等。同时也要根据自己的完成情况，不断的修正目标，因为太难的目标让我们一直没法达到，就会产生惰性。太容易的目标，没有挑战，自己很快也会厌倦。合适的目标是需要自己摸索出来了。</p><p><strong>后记</strong><br>我很提倡大家在平时努力去积累更多的知识，让尽量多的领域都不陌生，这样在未来的学习、工作中是有很大优势的。</p><p>有同学会发出这样的疑问，『我并不清楚自己未来工作中要用到什么，现在学了这些以后没用怎么办？』</p><p>在我看来，这样的担心不过是给自己偷懒找好的借口罢了。如果我们有清晰的职业规划，那么可以按照自己的规划去学习技能，补足自己的短板，为未来的发展蓄力。但更多的人可能并没有很清晰的职业规划，那么可以先在已有领域钻研更深。还有一些人对于现在自己做的事情，并没有太多兴趣，不想钻研太深。自己又不清楚未来要做什么，我建议此种状况下的同学尽量去多尝试其他领域的知识、技能，这样方便找到自己感兴趣的东西。</p><p>很多同学期望找到一种技能，学了就能一辈子无忧，不用一直学，这样就轻松多了。但在我看来没有一种技能是永远不会更新的，只是每种技能更新的周期不同罢了。比如软件工程师的技能更新周期就比钢琴家的技能更新周期短（不知道这个例子对不对，大概是对的吧）。某些技能的更新周期可能长达50年，100年。这些技能就很符合喜欢学一次终身受益的同学。但这类技能要么门槛低，收益低（这里要排除这个领域顶尖的那波人，因为要在一个领域做到顶尖门槛也不低），比如游泳、自行车、会计。要么门槛低、收益高、发展低，比如搬砖（这里我做个可能不大恰当的比较，大家理解就好。比如去工地搬砖，努力干一个月可以赚12000块。在星巴克当服务员，每个月工资6000块。这两份工作如何选择，大家心里都有数。抛开体面什么的不谈，个人发展也是非常重要的考量因素。除却家里有矿的同学，更多的同学会考虑职业前景。）。比如律师是很多同学眼中，高大上的职业，它所需的技能就是高门槛，更新周期长（一辈子可能很难遇到几次），学会了收益很高。再比如软技能中的人际交往能力、演讲能力等，它们实质上也在缓慢的更新，因为人是在变化的，这一代人和那一代人，在思维方式和行为习惯上都会有一定的改变，我们的软技能也需要更新，以便迎合。</p><p>每个人都应在一定时候，审视自己掌握的技能，去了解它们最新的进展。思考自己技能更新的周期，将技能做一个梳理，哪些是吃饭的，哪些是未来的规划，哪些是兴趣爱好，这样就能有的放矢的提升自己。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《Scrum敏捷软件开发》有感</title>
      <link href="/2018/05/26/%E8%AF%BB%E3%80%8AScrum%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E3%80%8B%E6%9C%89%E6%84%9F/"/>
      <url>/2018/05/26/%E8%AF%BB%E3%80%8AScrum%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E3%80%8B%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>本书是敏捷联盟及Scrum联盟创始人之一、敏捷估算及计划的鼻祖Mike Cohn三大经典著作中影响最为深厚的扛鼎制作，也是全球敏捷社区中获得广泛肯定的企业敏捷转型权威参考。</p><h3 id="敏捷软件开发宣言"><a href="#敏捷软件开发宣言" class="headerlink" title="敏捷软件开发宣言"></a>敏捷软件开发宣言</h3><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p><p><strong>工作和互动</strong> 高于 流程和工具<br><strong>工作的软件</strong> 高于 详尽的文档<br><strong>客户合作</strong> 高于 合同谈判<br><strong>响应变化</strong> 高于 遵循计划</p><p>也就是说，尽管右项有其价值，我们更重视左项的价值</p><h3 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h3><p>Scrum是一个用于开发和维护复杂产品的框架，是一个增量的、迭代的开发过程。整个开发过程由若干个短迭代周期构成，一个短迭代周期称为Sprint，每个Sprint的建议长度为2到4周。使用Backlog来管理产品需求，Backlog是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事。</p><p>简而言之这是一套流程规范，我们参照这套规范进行软件研发就能应对不断变化的需求。</p><p>软件研发中最痛苦的就是需求变更，尤其是对于研发工程师来说，每一次的变更都意味着『对上一次的否定』,是非常打击士气的。尤其是以半年为周期发布一个版本的大项目，在传统瀑布研发模式下，首先产品经理需要规划大量的需求，是非常可怕的事情。尤其是当产品复杂度增大的时候，人的思维严谨度是有限的，就很难保证<strong>需求文档</strong>的质量。在开发过程中发现需求和设计层面缺陷的可能性就会大大增加，导致项目越到后期，变动越频繁，进而影响团队氛围。</p><p>Scrum则将大迭代调整为小迭代，在一定程度降低了需求设计的工作难度。同时也能尽快的将可用的产品交付给用户，得到反馈，以便在下个迭代进行调整。这样通过多次迭代反馈，最终交付给用户满意的产品。</p><p>那么我们如何理解『拥抱变化』呢，是否意味着我们采用敏捷开发之后，就可以肆无忌惮的改需求了呢？我们先来看看中国特色的敏捷：</p><p><strong>极限编程</strong><br>每天只工作8小时，工作量不饱和，没到『极限』。</p><p><strong>拥抱变化</strong><br>『我的需求很简单，这里改一下，那里的审批流程不要了……』产品经理上午说好的需求，下午就变。</p><p><strong>迭代式开发</strong><br>做完了发版，有BUG下个版本修。</p><p><strong>Sprint冲刺</strong><br>版本要上线，今晚大家通宵努力一把。</p><p><em>不少公司的管理层其实并不真正关注敏捷，他们并不想改变自己。他们被广告打动了，『用敏捷吧，交付更快，质量更高。』于是敏捷成为了他们的新玩具。敏捷好啊，简单易懂，成本低廉，记得更快交付哟。</em></p><h3 id="迭代期内无变更"><a href="#迭代期内无变更" class="headerlink" title="迭代期内无变更"></a>迭代期内无变更</h3><p>首先我们要理解一下什么是<strong>变更</strong>。<br>我们通常意义上说的变更，就是频繁改需求。以前常听测试说的一句话是『都要发版了，还在改需求』，这种临近发版，功能细节的调整，风险是很大的。但这种情况在软件研发的过程中却经常发生。对于一个大功能模块来说，一个影响业务流程的改变对于产品经理来说可能是一句话，对于研发和测试来说可能就是前面几天的努力都白费了，还得再来一次，但时间可没那么多了，于是项目延期，出现质量问题的风险大增。</p><p>上面说到的是<strong>功能细节的频繁变更</strong>，还有一种是<strong>迭代开发已经开始，还没明确要开发什么功能</strong>。我觉得这种问题至少我是没有遇到过的，如果一个团队出现这个问题，那我认为是项目经理的重大失职。每个产品的版本迭代都是企业的一步棋：<strong>在某个时间，推出某些功能，满足某些需求，获取某些客户，打败某些对手，取代某些产品。</strong>若认同了这一点，则早在产品版本规划的时候，就应该确认此版本中应该大致包含哪些功能，而非到迭代计划会议或迭代中才会确认，更不会在迭代中间发生变化。</p><p>通过一番思考，我的理解是<strong>在迭代周期内不要进行影响业务流程的需求变更。</strong>倘若不得不这么做（该变更不能放到下次迭代调整），我们需要反思为何产生这种变更，是在做需求分析出现了偏差，还是客户的需求发生了本质上的变化。2-4周的短迭代本身就是对用户需求的<strong>渐进明细</strong>的过程，但<strong>渐进明细</strong>是要保证对用户需求的理解在大方向上是没有问题的，这样通过<strong>多次迭代</strong>，使产品越来越接近更满足用户需求的样子。而不能是<strong>每次迭代</strong>对用户需求的理解都是<strong>南辕北辙</strong>的。<em>举例，用户想要一个能让他从A地快速移动到B地的工具。按照渐进明细的敏捷研发方式，我们第一个迭代做了一个滑板，第二个迭代做了一辆自行车，第三个迭代做了一辆汽车。在这三次迭代中，我们对客户需求的理解，在大方向上是没有问题的，并在每一次迭代都交付给了客户比上一次更接近需求标准的产品。假如我们第一次迭代做了一个扳手，第二次迭代做了一把螺丝刀，第三次迭代计划是做电钻，但在研发一周后产品经理突然领悟到做一个滑板更接近需求，于是要求改做滑板。那么以上三次迭代就是刚才说的南辕北辙式敏捷研发。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风险、问题、依赖项和假设管理介绍</title>
      <link href="/2018/05/12/%E9%A3%8E%E9%99%A9%E3%80%81%E9%97%AE%E9%A2%98%E3%80%81%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%92%8C%E5%81%87%E8%AE%BE%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/05/12/%E9%A3%8E%E9%99%A9%E3%80%81%E9%97%AE%E9%A2%98%E3%80%81%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%92%8C%E5%81%87%E8%AE%BE%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>所有的项目，无论大小都会有风险，问题，依赖项和假设。管理它们是项目经理工作中最耗时间的事，但是我们能将它们管理好的话，我们将减少延误和成本超支，将更好的和干系人沟通，我们的项目交付将更好。和项目管理领域的所有事情一样，这些事情越早明确越有益。</p><p>正确使用RAID管理将帮助你：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>在潜在问题发生之前将其处理</span><br><span class="line"><span class="bullet">- </span>清楚何时需要向更高层级请求帮助</span><br><span class="line"><span class="bullet">- </span>确保每一个人都明白自己的职责</span><br><span class="line"><span class="bullet">- </span>将项目计划、交付依赖和你为项目做的假设，通知所有干系人</span><br></pre></td></tr></table></figure><p>#风险和问题#<br>风险是可能会发生，但尚未发生的问题。尽早的关注这些问题，能大大降低他们发生的可能性，并且影响你的交付能力。当问题已经发生，那么风险和问题的类型包括：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>资源可用性：在项目中你是否有足够的各个类型的资源？</span><br><span class="line"><span class="bullet">- </span>资源连续性：能否在项目周期中使用同一资源？这是很重要的，因为替换资源很花时间。</span><br><span class="line"><span class="bullet">- </span>质量问题：你是否有承诺交付项目的质量？你是否做出了可能影响质量的妥协？</span><br><span class="line"><span class="bullet">- </span>市场风险：市场的变化可能使你的项目处于风险中。假如，你所在市场的产品创新非常快，那么延期的风险会对项目成功交付造成影响。</span><br><span class="line"><span class="bullet">- </span>技术风险：你的项目是否包含新技术，他是否影响许多系统组件。</span><br><span class="line"><span class="bullet">- </span>流动性：你是在一个流动性很强的组织工作，还是在一个人们经常改变主意的地方工作？你的产品进入了一个快速变化的市场吗？</span><br><span class="line"><span class="bullet">- </span>监督管理：监管需求是否为你的项目带来了风险，或者您的项目是否会因为违反法规而无法交付？</span><br><span class="line"><span class="bullet">- </span>治理：你是否有靠谱的投资方和领导，还有指导委员会的人员。这些风险通常都是高度政治性的，因此很难公开，但你必须意识到它们，并且愿意『离线』处理它们。</span><br><span class="line"><span class="bullet">- </span>变更影响：如果你的项目将改变人们的工作方式，那么它不被接受的风险将提高，这是需要解决的。</span><br><span class="line"><span class="bullet">- </span>供应商风险：了解你的供应商，做好调查将帮助你了解你的供应商的风险等级。他们是唯一可用的供应商吗？如果是这样的话，项目的风险变得更高了。他们产品在质量上的名声怎么样？他们已经创立了多久？</span><br><span class="line"><span class="bullet">- </span>物流风险：如果你的项目涉及到团队迁移，那么你的物流风险将比你为销售团队提升CRM系统的风险要高得多。如果你的团队分布在广泛的地理范围内，那么你的风险就会比你整个团队坐在同一层楼的风险要高。如果项目/开发团队远离业务用户和赞助商，风险也会变高。</span><br></pre></td></tr></table></figure><p>#依赖#<br>依赖关系有两种：（1）对外依赖，你的项目完成依赖另一个项目组任务的完成。（2）内部依赖，其他团队在完成交付之前依赖于你先交付。列如，你修改一个表单之前需要法务部门的审查，这是一个外部依赖。</p><p>了解依赖关系意味着能够尽早的发现问题，跟进问题找到解决方案。依赖的例子包括：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>在你开始测试之前另一个系统必须完成编码。</span><br><span class="line"><span class="bullet">- </span>在你打印新版本合同邮寄给客户之前需要法律部门先审核。</span><br><span class="line"><span class="bullet">- </span>在你开始建造之前规划部门要先批准。</span><br><span class="line"><span class="bullet">- </span>在你正式开始项目之前组织的另一些人需要先批准费用。</span><br><span class="line"><span class="bullet">- </span>为了完成业务需求文档，需要和进行五次需求沟通。</span><br></pre></td></tr></table></figure><p>依赖必须得到各方的同意 —— 你不能依赖于别人团队代码交付来确定交付日期，举个例子，没有团队同意这个交付日期。同样的，如果你再没开始就没同意交付日期，你也不用为别的团队的交付日期负责。</p><p>#假设#<br>当我们在做规划项目时，尤其是在完成详细的业务和技术分析之前，我们都会做许多假设。我们通常不认为能把计划做得多详细。记录下这些假设，意味着项目每一个人对都有相同的理解。假设的例子包括:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>关于供应商的活动，例如，你假设供应商在将任何新代码交给您之前，将进行完整的单元测试。</span><br><span class="line"><span class="bullet">- </span>你目前使用的模型适用于此项目。</span><br><span class="line"><span class="bullet">- </span>新网线的安装将作为另一个项目交付的一部分，所以不会包含在你的项目中。</span><br></pre></td></tr></table></figure><p>零散的翻译完了这篇文章，浓浓的机翻即视感。英文还要继续修炼啊。</p><p><em>原文地址：<a href="http://thetruemanager.com/risk-issue-dependency-assumption-raid-management-introduction/" target="_blank" rel="noopener">http://thetruemanager.com/risk-issue-dependency-assumption-raid-management-introduction/</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完的4.0</title>
      <link href="/2018/03/28/%E6%9C%AA%E5%AE%8C%E7%9A%844-0/"/>
      <url>/2018/03/28/%E6%9C%AA%E5%AE%8C%E7%9A%844-0/</url>
      
        <content type="html"><![CDATA[<p>想说些什么，却又不知从何说起。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考感悟</title>
      <link href="/2017/12/28/PMP%E5%A4%87%E8%80%83%E6%84%9F%E6%82%9F/"/>
      <url>/2017/12/28/PMP%E5%A4%87%E8%80%83%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/default.jpeg" alt="default"><br>今天知道了PMP的考试成绩，我很幸运的拿了5A，这也是对我三个多月来的备考付出最好的回报。</p><p>其实刚开始拿到PMBOK的时候，确实心里『咯噔』了那么一下。那么厚的一本书，看起来很吃力啊。不过随着学习的深入和余老师的引导，慢慢的我对整个PMBOK的知识结构有了一定的认识，书也就不那么厚了。</p><p>我的备考经验简单总结起来就是做好三件事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一、课前预习，在上课之前认真看几遍书真的是很重要的，至于具体几遍，我认为可以根据个人阅读习惯和掌握情况调整。课前的预习能让我们对书中的『术语』『概念』有大致的印象，有助于老师在讲课的时候，我们能跟上老师的思路，加深影响。同时也可以关联自己平时的工作场景，强化记忆。课前预习阶段看书PMBOK就好，不建议预习完就去刷题，或是看之外的参考书，这样容易误导我们的思想，毕竟PMBOK才是根本。</span><br><span class="line"></span><br><span class="line">二、课中认真听讲，仔细在书上做好笔记。课堂上的强度还是蛮大的，尤其是下午，人困马乏之际，更是要打起精神，听清楚老师讲的每一个『考点』。课上没听懂的，在书上做好标记，课间的时候可以向老师请教。一定要尽量在课堂上搞懂，不然后期刷题的时候会让自己很慌张。</span><br><span class="line"></span><br><span class="line">三、课后认真做题，积极参加小组讨论。课后测试题是一定要认真做的，它能帮助我们尽快熟悉PMP考试的套路。个人建议是单独准备『答题卡』做题，不要直接在测试题上标注，这样冲刺阶段的时候还能将测试题拿出来重做。学习小组也是非常重要的，大家一定要积极参加自己所在小组的活动。毕竟PMP考试并没有『标准答案』，而是相对『合适的答案』，所以大家针对答案的讨论真的非常重要，可以了解到更多的解题思路。清晖QQ群里面发的每日一题，也是要认真对待的，可以记下来冲刺阶段再看看。</span><br></pre></td></tr></table></figure><p>做好以上三点，我相信通过考试是没有问题的。另外在最后的冲刺阶段，以清晖发的试题为准就行了，不用去网上找题库什么的，那没有什么意义的。题在于精而不在于多，深刻理解每道题的考点才是关键。也不要钻牛角尖，纠结于对错，毕竟外国人的思维方式、处事风格和我们还是有一定差异的。</p><p>在此感谢清晖余老师、谭老师三个月的陪伴，祝往后的学弟、学妹们都能取得好成绩。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP第二周培训</title>
      <link href="/2017/10/29/PMP%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%9F%B9%E8%AE%AD/"/>
      <url>/2017/10/29/PMP%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<p>这周的培训强度有点大，两天都晕晕乎乎，特别是涉及复杂的计算题。到课程最后就是机械的记录了，脑袋已经不动了。(发现馥芮白的咖啡含量果然比拿铁高，第一天下午为了不打瞌睡，喝了个大杯馥芮白，结果心脏跳得很厉害，课后回家觉得很乏，但就是睡不着。第二天喝的拿铁，就没有心跳加速那种感觉)</p><p>这周重点讲了以下方面：</p><ul><li>项目成本管理</li><li>项目质量管理</li><li>项目人力资源管理</li><li>项目沟通管理</li><li>项目风险管理</li><li>项目干系人管理</li></ul><p>其中<strong>项目成本管理</strong>中的<strong>挣值管理（EVM）</strong>作为有大量计算题的一个知识点，确实给大家带来了不小的困扰。</p><p>第一个难点在于有好几个需要记住的缩写，比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EV，挣值</span><br><span class="line">PV，计划价值</span><br><span class="line">AC，实际成本</span><br><span class="line">SV，进度偏差</span><br><span class="line">CV，成本偏差</span><br><span class="line"><span class="built_in">SPI</span>，进度绩效指数</span><br><span class="line">CPI，成本绩效指数</span><br><span class="line">BAC，完工预算</span><br><span class="line">EAC，完工估算</span><br><span class="line">ETC，完工尚需估算</span><br><span class="line">TCPI，完工尚需绩效指数</span><br><span class="line">VAC，完工偏差</span><br></pre></td></tr></table></figure><p>以上缩写和名词可能看单个的时候还是挺容易理解的，但是当糅杂在一起的时候，就很容易记混了。<br>再配上它们之间复杂的公式，比如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SV</span> = EV - PV</span><br><span class="line"><span class="attr">SPI</span> = EV / PV</span><br><span class="line"><span class="attr">CV</span> = EV - AC</span><br><span class="line"><span class="attr">CPI</span> = EV / AC</span><br><span class="line"><span class="attr">ETC</span> = (BAC - EV) / CPI</span><br><span class="line"><span class="attr">ETC</span> = BAC - EV</span><br><span class="line"><span class="attr">ETC</span> = (BAC - EV) / (CPI * SPI)</span><br><span class="line"><span class="attr">EAC</span> = AC + ETC</span><br></pre></td></tr></table></figure><p>脑袋已晕😓😓😓。</p><p><strong>质量管理</strong>和<strong>风险管理</strong>的考点也蛮多了，<strong>控制质量</strong>中的七种工具等知识也是需要牢牢记住的。</p><p>课堂上也公布了上周测试题的答案，30到题错了9道，勉强及格。其中有2，3道题属于自己疏忽了，被题干欺骗，看来还没有熟悉考题套路，希望随着做题的增多，自己能对题目套路更熟悉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP第一周培训</title>
      <link href="/2017/10/20/PMP%E7%AC%AC%E4%B8%80%E5%91%A8%E5%9F%B9%E8%AE%AD/"/>
      <url>/2017/10/20/PMP%E7%AC%AC%E4%B8%80%E5%91%A8%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<p>上个周末的两天，参加了PMP的第一周培训。总的来说感觉还不错，老师讲得挺有趣的，且结合自身经验给我们讲授了项目管理的一些知识。</p><p>《PMBOK》我在国庆假期之前看了一遍，假期中又看了一遍。记住的不多，但是对PMI项目管理的整体脉络还是有了一定映像。五大过程组，十大知识领域已经基本可以记住，但过程中的ITTO还是记不住的，感觉特别多而杂，需要在学习中再好好总结一下，一定要在考试钱记住。</p><p>两天的学习中，给我映像比较深的有『三点估算』，用来估算项目进度，感觉特别适用。<br>以前自己在估算项目进度的时候，更多的依赖经验，并没有利用『公式』来估算，了解到『三点估算』之后，将可以用更科学的方法来估算项目进度了。</p><p>『项目进度网络图』也是很好的东西，能帮助我们快速的了解项目进度结构，分析出哪些任务是关键节点，对于项目进度的影响最大。同时我也现学现用的在产品下个版本的进度规划中使用了起来。</p><p>学习回来之后，我尝试使用OmniPlan对接下来的版本计划进行管理，发现OmniPlan的设计完美契合了PMI的理论，使用起来很顺手。虽然Omni这套软件我收入囊中已经很久，而且该软件大名在外。只是以前使用的时候，觉得怪怪的，通过学习之后，发现了其中的精髓，使用起来自然顺手了很多（同时也在使用OmniOutliner整理PMBOK的读书笔记，也是比较好用的）。</p><p>这周末没有课，周日参加学习小组的聚会。感觉自己做错的题还是蛮多的，和小组其他同学比起来还差一下，有必要回来恶补一下了。很期待下周的课程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于PMP的一些事</title>
      <link href="/2017/09/17/%E5%85%B3%E4%BA%8EPMP%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
      <url>/2017/09/17/%E5%85%B3%E4%BA%8EPMP%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>知道PMP应该是在13年的时候，当时一群人在天台闲聊，一个同事提到自己的规划是在后面两年要拿下PMP证书。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PMP指的是项目管理专业人士资格认证。它是由美国项目管理协会（<span class="keyword">Project</span> Management Institute(PMI)发起的，严格评估项目管理人员知识技能是否具有高品质的资格认证考试。</span><br></pre></td></tr></table></figure><p>后来随着工作的繁忙，渐渐将这事儿忘了。但随着项目的扩大，自己的管理职能越来越多，慢慢感觉需要一套理论来找找感觉，于是又想起了这事儿。</p><p>原计划16年就去系统学习一下，但因为团队刚扩大，还有很多更重要的事情，便耽搁了。今年随着团队的稳定，在管理『方法论』上，我也希望有新的『突破』，于是确定报考PMP。</p><p>上周风风火火的去报了培训，开始利用业余时间啃PMBOK，还是颇有感受的（谈不上收获，只是结合自己目前的管理方式，再看看书上的理论，觉得有值得借鉴的地方）。</p><p>比如项目管理的五大过程：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>启动</span><br><span class="line"><span class="bullet">* </span>规划</span><br><span class="line"><span class="bullet">* </span>执行</span><br><span class="line"><span class="bullet">* </span>监控</span><br><span class="line"><span class="bullet">* </span>收尾</span><br></pre></td></tr></table></figure><p>就很容易对应软件工程中的『瀑布开发模型』。</p><p>这套理论更多的是对我们的一种方向指导，最终还是要结合团队及项目实际情况变通处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗伯特议事规则</title>
      <link href="/2017/07/30/%E7%BD%97%E4%BC%AF%E7%89%B9%E8%AE%AE%E4%BA%8B%E8%A7%84%E5%88%99/"/>
      <url>/2017/07/30/%E7%BD%97%E4%BC%AF%E7%89%B9%E8%AE%AE%E4%BA%8B%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><strong>如何在没有权威的情况下平等自治、达成共识、重建秩序。</strong></p><ul><li>动议可行原则 <em>什么样的问题可以拿来讨论?</em></li><li>主持中立原则 <em>总是『领导说了算』如何应对</em></li><li>弃权无效原则 <em>有人不表态想当『老好人』怎么办</em></li></ul><p>周末的时候看完《可操作的民主》一书，对于<strong>罗伯特议事规则</strong>产生了浓厚兴趣。同时觉得该书作为一本『纪实书籍』(不知道是不是有这种分类方式)，语言诙谐，在叙述已发生的事情时，将<strong>罗伯特议事规则</strong>娓娓道来，让读者不觉得枯燥，实在是很难得的。</p><p>我在工作中，也有各种各样的会议。有些乱哄哄的，有些开半天不明所以，有些主持人就是个『暖场』的角色，尤其是那种需要『作出确定』的会议，大部分的时候都没有结果，最终领导决定，大家才『服气』。了解到『罗伯特议事规则』后，我有种豁然开朗的感觉，缜密的规则，保证了会议能得出结果，保障每个人的权利。往后将在团队会议中引入，让会议有序高效。</p><p>『是领导不民主，还是我们自己已习惯依赖领导？追求自由，我们是否明白边界的含义，是否理解规则的价值？追求民主，我们能否接纳平等带来的折磨，包容多元引致的碰撞？到底是文化决定规则，还是规则塑造文化？』这是本书封面的一句话，尤其最后一句『文化』和『规则』的关系，让我有了一些在团队建设方面的思考。</p><p>本书的两位作者<em>寇延丁、袁天鹏</em>也是著名的民间公益行动者，其中<em>袁天鹏</em>本身也是议事规则专家，同时也是中文版《罗伯特议事规则》的译者，是《罗伯特议事规则》在中国的布道人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySqlParameter的坑</title>
      <link href="/2017/06/11/MySqlParameter%E7%9A%84%E5%9D%91/"/>
      <url>/2017/06/11/MySqlParameter%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个MySQL相关的坑，这里简单记录一下。<br>在.Net中执行MySQL语句传参的时候我们一般使用MySqlParameter对象。于是在某个Dao层的方法中，我写了如下的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var parms = new MySqlParameter[]</span><br><span class="line">&#123;</span><br><span class="line">new MySqlParameter(&quot;?Type&quot;,(int)StatusType.Normal)</span><br><span class="line">&#125;</span><br><span class="line">string sql = @&quot;SELECT * FROM TABLE T WHERE T.Type = ?Type;&quot;;</span><br></pre></td></tr></table></figure></p><p>结果是死活查不出数据，但是将SQL直接拿到服务器上运行，确能正常查出数据，实在是让人费解。随着不断调试，发现MySqlParameter的Value值不知为什么一直为null，后来试着改写了语句，用一个临时变量存储枚举值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int type = (int)StatusType.Normal</span><br><span class="line">var parms = new MySqlParameter[]</span><br><span class="line">&#123;</span><br><span class="line">    new MySqlParameter(&quot;?Type&quot;,type)</span><br><span class="line">&#125;</span><br><span class="line">string sql = @&quot;SELECT * FROM TABLE T WHERE T.Type = ?Type;&quot;;</span><br></pre></td></tr></table></figure></p><p>查询就正常了。</p><p>原来问题出在MySqlParameter的构造函数上，有两个关键的构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public MySqlParameter(string name, object value) &#123; </span><br><span class="line">    // ...... </span><br><span class="line">&#125; </span><br><span class="line">public MySqlParameter(string name, MySqlDbType type) &#123; </span><br><span class="line">    // ...... </span><br><span class="line">    // MySqlDbType是个枚举类型 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们第一次调用的时候，因为枚举为0，所以被当做第二个构造函数调用了。但是经测试当枚举不为0的时候，使用第一种调用方式，还是会使用第一种构造函数，确实令人看不懂。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行为驱动开发</title>
      <link href="/2017/05/21/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2017/05/21/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>流行的「敏捷软件开发」技术中的TDD，想必大家都听过，但是还有一种BDD(Behavior-driven development)行为驱动开发知道的人恐怕就很少了。我也是在去年参加蚂蚁金服技术开发日的时候了解到了，我在这里简单整理一下。</p><p>BDD鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。</p><p>BDD的做法包括:</p><blockquote><ul><li>确立不同利益相关者要实现的远景目标。</li><li>使用特性注入方法绘制出达到这些目标所需要的特性。</li><li>通过由外及内的软件开发方法，把涉及到的利益相关者融入到实现的过程中</li><li>使用例子来描述应用程序的行为或代码的每个单元。</li><li>通过自动运行这些例子，提供快速反馈，进行回归测试。</li><li>使用“应当(should)”来描述软件的行为，以帮助阐明代码的职责，以及回答对该软件的功能性的质疑。</li><li>使用“确保(ensure)”来描述软件的职责，以把代码本身的效用与其他单元(element)代码带来的边际效用中区分出来。</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 开发模式 </tag>
            
            <tag> BDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>170312</title>
      <link href="/2017/03/12/170312/"/>
      <url>/2017/03/12/170312/</url>
      
        <content type="html"><![CDATA[<p>今年计划中的三个重大版本的第一个，已经在上周发布了。整个流程没有出什么大问题，不过大家还是一起折腾到了第二天的凌晨3点。我简单算了一下，我们从20:30分开始更新数据库，21点的时候更新完毕开始测试。两个人测试新版本，两个人测试老版本。老版本只测常用功能，新版本则照例将所有功能跑一遍。在这6个小时中，修改BUG的时间其实不到一个小时，研发同事很长一段时间都是在等待测试结果，所以目前发版的瓶颈在测试效率上，考虑到整个产品的功能只会多不会少，所以我需要好好思考一下如何优化测试流程，能引入什么工具来提升测试效率。</p><p>最近利用Jenkins和阿里云Code进行了自动构建的测试，决定下个版本使用起来。关于自动构建，以前在上一个团队的时候简单了解过，那个时候用的是FinalBuilder，貌似是很古老的持续集成工具（我也不是很了解FinalBuilder，当时是另一个同事在做这个事情。上周有其他项目组的同事过来跟我讨论自动构建的问题，提到FinalBuilder，说是不想用那个古老的东西）。Jenkins + 阿里云Code + 蒲公英，看起来是一套很棒的组合。</p><p>整个服务器的架构一直是我想要进行调整的，目前手机端服务使用WCF搭建，Web端则是自己单独的一套，所以每次做新功能的时候经常是服务端的同事写一套，Web端的同事还要再写一遍，大大降低了研发的效率。目前我的想法是废弃掉WCF，采用WebAPI提供服务。Web端和手机端都通过WebAPI与数据库进行数据交互，这样就将Web端和手机端的数据源整合统一起来，并且有利于提升研发效率。现在我在思考WebAPI端的架构，是完全按照Restful风格呢（完全按照Restful风格来设计接口也挺难的），还是根据业务形成一套自己的风格。</p><p>入手了一本讲克苏鲁神话的书，第一次知道克苏鲁神话是玩血源诅咒的时候，看攻略了解到的。影响最深的是克苏鲁神话的中心思想是『知道得越多，死得越快』，o(╯□╰)o。</p><p>读库1702到了，简单翻了翻目录，发现里面有篇马伯庸的文章，应该是我喜欢的类型，决定先看。同时寄来的还有一本讲植物智能的书，书的封皮很棒，是织物的那种感觉，是一本很精致的书。同事提到以后买实体书，要先看封面好不好看，○|￣|_。</p><p>手中的iPhone 6 Plus越来越不争气，尾插充电也越来越不好使，考虑到今年iPhone有重大更新，于是不打算换iPhone 7 Plus，先拿备用机红米Note3顶半年再说。这几天使用红米还算凑合，双卡双待确实挺爽的，很喜欢iPhone未来也支持这个功能，这样我能在电信4G网络不好的时候，切换到移动4G。</p><p>入手了QCY的Q29蓝牙耳机，类似于苹果AirPods那种，不过外观倒是没有山寨。相对于AirPods 1000+的价格，Q29目前199的价格实在是实惠。已经用了两天了，感觉还不错，主要因为我是木耳，也听不出好坏。唯一的问题是，耳机放充电盒子充电的时候不是很紧，稍微动一下耳机和充电头就会接触不良，充不了电。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于《读库》</title>
      <link href="/2017/02/18/%E5%85%B3%E4%BA%8E%E3%80%8A%E8%AF%BB%E5%BA%93%E3%80%8B/"/>
      <url>/2017/02/18/%E5%85%B3%E4%BA%8E%E3%80%8A%E8%AF%BB%E5%BA%93%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>《读库》这本『杂志』我是很早就听说过的，记忆中是在池建强老师的文章中看到的，同时池建强老师也推荐了一番。正好年前在杂志铺翻杂志的时候想了起来，就索性去天猫订了一年。年后假期回来，第一时间就拿到了1700和1701，很欣喜那么快就拿到书了，于是迫不及待的拆开了快递包装。</p><p>刚拆开包装的时候，两本蛮厚的书出现在眼前。那在手上，那分量感觉又有点不对，谁能想到那样有『厚重感』的外形，拿在手里却又是那样的轻呢。将近400页的书，比那些200页的书都轻了不少。尤其是对于我这种看惯了大部头的技术男来说，更是觉得有点匪夷所思。后来在网上了解到，《读库》为了保证阅读的舒适，特地选择了更轻的纸来印刷。</p><p>读库的封面很简洁，没有多余的文字和色彩。我很难用合适的词汇来描述它的这种简洁，或许是看惯了大大的LOGO，花花绿绿的封面。面对这种简洁的封面，有一种莫名的好感。</p><p>摸着书的封面，有一种磨砂的感觉。内页的纸摸起来也很舒服，感觉很软，韧性很好，并不会因为薄和轻而变得易碎。</p><p>内容上，1700更多的是一种总结回顾，不过里面记录的事情还是挺有趣的。1701还没有细细品味，这里就不多说了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016总结</title>
      <link href="/2017/01/15/2016%E6%80%BB%E7%BB%93/"/>
      <url>/2017/01/15/2016%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>今天是2017年的第一天，白天一直在外面逛商场什么的挺累的。晚上在家，这个点很适合静静的整理一下思绪，将2016年的经历做一个简单的总结。</p><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><p>去年对我个人来说是挺重要的一年，因为这是我毕业的第五年。以前我看过一篇文章，说是一个毕业生的前两年是成长最快的时候，同时也是确立职业目标的时候。你需要在这两年中，快速的找到适合自己的岗位，为将来的发展打好基础。对于我而言，我很庆幸的是我在很早的时候就确立了我的职业目标，我选择的职业也是我最爱的。所以我在我的岗位上没有过迷茫，只想着快点成长起来。在工作前两年的时候，就是疯狂的学习技术，花大量时间去看书，尝试新技术，参加各种技术交流会，看着大牛们在技术交流会上侃侃而谈，我梦想着自己有一天能像他们一样。</p><p>前两年的快速成长之后，第三、第四年是一个成熟期。这个时候经历了快速成长的年轻人，现在应该是公司的业务骨干，技术上趋于成熟，这个时候需要追求一定的技术深度，同时在处理问题上，不止能解决好技术本身上的问题，还是有意识的能协调非技术上的问题。</p><p>第五年则是对自己的检视，这个时候可能已经带过小团队，在公司或许是中低层管理者，或许面对技术或管理的转型，这个时候通常离自己的职业规划，已经有比较清晰的升迁路径。这个时候更需要针对性的提升自己，补足自己的短板。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>iOS端持续的进行着重构工作。重新封装了网络请求，将AFN替换为NSURLSession，并针对业务进行了封装。同时对整个APP的架构进行了改造，引入ViewModel层，让ViewController变得更干净。引入ReactiveCocoa，尝试函数式编程，目前用得还挺浅的，主要停留在处理事件响应阶段。整个APP的重构是一个持续的工程，同时我们也在不停的修正一些架构上的错误。</p><p>年中的时候，服务器时不时的抽风，这段时间学习了大量运维方面的知识，也因为到处问问题，遭过不少白眼。但我觉得挺值得的，正是这样使我对运维工作有了新的认识，同时学到了不少知识。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>入手了一直想要的游戏机，作为一个很小就在街机厅玩的人，拥有一台自己的游戏机一直是我的一个小梦想，今年终于实现了，入手了PS4和3DS，目前努力攻略FFX和火纹IF。</p><p>9月份的时候陪老婆去了趟韩国，感觉只能算凑合吧，毕竟自己对那些电视剧中的景点无爱，我也不爱韩剧。不过我对韩国这个国家还是心存敬畏的，毕竟能在短短几十年间成为发达国家的一员，一定有其可取之处。</p><p>11月的时候开始健身和游泳，主要为了控制日渐增长的体重。经过折腾顺利学会了蛙泳，目前游一个来回问题不大。器械训练上，感觉自己的力量不是很足，现在也有这方面的锻炼。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>2017年对于产品来说是关键的一年，也是技术团队走向成熟提升的一年。我在个人能力上也将着手进行新的提升。打磨自己的管理能力并形成自己的管理风格。对于技术团队的管理，有三个要点<em>团队共享、划分纬度、循环执行</em>，今年我的努力方向就是做好这三点。</p><h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><p>2016年初的时候，研发团队经历了较大的人员变动，所以大半年的时间都在进行磨合，随着人员磨合的到位，2017年的研发效率将稳步提升。还有一些先进工具的引入，也是新的一年里的重要工作，比如GitLab、Fastlane、Jenkins实现持续集成，让做包测试的流程很高效。</p><p>随着业务量的增长，对于我们的程序架构也会有新的要求，比如一直计划将WCF换为更易用的WebAPI，因为时间的原因一直没有处理，目前比较紧迫的事情为解决基础框架(方法)无法满足新业务的问题。</p><h2 id="技术-1"><a href="#技术-1" class="headerlink" title="技术"></a>技术</h2><p>2016年年初的时候进行了数据库分表和数据库迁移，年末的时候对照片进行了迁移，并做了负载均衡。还有很多报表的优化，总得来说16年团队技术上的提升还是挺大的，特别是随着用户越来越多，数据量越来越大，对整个后台服务都将是是考验。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>2016年在团队的管理上还是比较粗放的管理，主要是基于版本任务完成情况的管理方式。该方式在人员相对较少的时候，是一种高效的管理方式。但随着人员的增多，单纯基于任务完成度的管理，无法多元化的去评价一名技术人员的贡献。还有团队能力的提升，也是不能单纯依靠任务完成度来进行管理的。</p><h2 id="规划-1"><a href="#规划-1" class="headerlink" title="规划"></a>规划</h2><p>在2017年，研发团队将关注三个要点：</p><ul><li>团队共享 —— 目标制定上下通透，目标制定的过程不仅仅是自上而下或自下而上的过程，而是两者交替进行，最终实现目标与整个团队的深度整合。</li><li>划分维度 —— 业务、技术需要整体考虑，平衡发展。</li><li>循环执行 —— 目标拆解成具体行动，形成习惯，持续反馈。</li></ul><p>技术上，争取引入更多高效的技术手段，能解决困扰我们的轨迹、监控等问题。</p><p>PS:拖拖拉拉两周多才写完，突然觉得自己的写文确实不如初中、高中时那么顺畅。现在写起来结结巴巴的，有时还不通顺，看来还得多练了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目中AOP的使用</title>
      <link href="/2016/12/25/%E9%A1%B9%E7%9B%AE%E4%B8%ADAOP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/12/25/%E9%A1%B9%E7%9B%AE%E4%B8%ADAOP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>Aspect Oriented Programming 面向切面(切片)编程的缩写。</p><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p><strong>在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong>这句话清晰简洁的给AOP做了定义。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向方面编程（AOP）是施乐公司帕洛阿尔托研究中心（Xerox PARC）在上世纪<span class="number">90</span>年代发明的一种编程范式，但真正的发展却兴起于近几年对软件设计方兴未艾的研究。</span><br><span class="line"></span><br><span class="line">由于软件系统越来越复杂，大型的企业级应用越来越需要人们将核心业务与公共业务分离。AOP技术正是通过编写横切关注点的代码，即“方面”，分离出通用的服务以形成统一的功能架构。它能够将应用程序中的商业逻辑同对其提供支持的通用服务进行分离，使得开发人员从重复解决通用服务的劳动中解脱出来，而仅专注于企业的核心商业逻辑。</span><br><span class="line"></span><br><span class="line">因此，AOP技术也就受到越来越多的关注，而应用于各种平台下的AOP技术也应运而生。但由于AOP技术相对于成熟的OOP技术而言，在性能、稳定性、适用性等方面还有待完善，同时AOP技术也没有形成一个统一的标准，这使得AOP技术的研究更具有前沿性的探索价值。</span><br></pre></td></tr></table></figure><h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><p>AOP能将事务处理、日志管理、权限控制、异常处理等封装起来，以便于减少系统的重复代码，降低模块间的耦合，使业务代码更纯粹易读，且有利于未来的可操作性和可维护性。</p><h2 id="处理繁琐的菜单-amp-操作权限"><a href="#处理繁琐的菜单-amp-操作权限" class="headerlink" title="处理繁琐的菜单&amp;操作权限"></a>处理繁琐的菜单&amp;操作权限</h2><p>在XXX管理系统中，菜单权限是必不可少的。并且随着企业管理的精细化，菜单的各种操作权限判断也是越来越多，所以简洁统一的处理方式是很有必要的。</p><p>在我们的项目中，每一个菜单权限都可能涉及到操作权限，它们包括：查看、新增、编辑、删除、审批、分配、重置、轨迹、下载、转移、退回、转为客户等11个。随着产品功能的不断完善，操作权限也将会越来越多。如果我们在每个ViewController的ViewDidLoad方法中去判断控制的话，工作量会非常的大。而且如果以后操作权限有变动的话，我们还得每个ViewController都去修改，很容易漏改。那么有简单的处理方式吗？</p><p>当然利用AOP思想和Objective-C runtime的特性，我们可以像下面这样处理：</p><ol><li>利用分类或继承，为每个ViewController都添加权限相关的属性。</li><li>利用runtime的特性，植入权限验证代码(通常替换ViewDidLoad方法)。</li><li>创建权限相关的控件时提供固定的Tag值(比如EditButton的Tag值为1000，NewButton的Tag值为2000)。</li><li>在新的ViewDidLoad方法中利用第一步中的权限属性，对权限相关控件(利用Tag来获取相关控件)进行统一操作，这样就实现了在所有ViewController中统一判断权限。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">还有另一种不替换ViewDidLoad的方法。</span><br><span class="line"></span><br><span class="line">即利用分类，在ViewController的分类中新添加一个类方法，比如叫VerifyPermission。在该方法中判断相关权限。这样只需要在所有ViewDidLoad中手动调用一次VerifyPermission即可。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>韩国旅游</title>
      <link href="/2016/11/03/%E9%9F%A9%E5%9B%BD%E6%97%85%E6%B8%B8/"/>
      <url>/2016/11/03/%E9%9F%A9%E5%9B%BD%E6%97%85%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>前段时间去韩国首尔和济州岛转了转，个人对于韩国没什么感觉，了解也仅限于三星，LG等等。对于韩剧什么滴完全木有兴趣，不过老婆倒是挺激动地o(╯□╰)o。</p><p>大概3个小时左右的飞机，我们到了仁川机场。下了飞机还要坐地铁才能从航站楼到出关的地方o(╯□╰)o，把我吓到了，这机场是有多大。出了机场大概1个小时的车程就到了首尔，然后参观了青瓦台和景福宫。青瓦台周围的警察大哥确实挺帅的，而且都有擦粉。路上的汽车基本都是韩国产的，现代、起亚、双龙、三星等等。晚上8点左右飞济州岛。</p><p>第二天在济州岛，天气实在是不好，一直在刮风下雨。不过没有影响的女士们的热情，参观了好几个韩剧中出现了的景点（反正我是不知道到底是什么景点）。冷得实在不行，在某个景点喝了杯咖啡，味道感觉还是不错的。另外每一顿饭都有辣白菜，墙面一两顿还好，后面实在是不想吃了。</p><p>第三天上午在济州岛逛了逛果园，买了些特产。下午回到首尔，晚上貌似吃了顿韩国烤肉（其实在去韩国前一天，我们在成都也去吃了顿韩国烤肉。。。。。），味道个人觉得属于不难吃。</p><p>第四天去了首尔塔，感觉还不错，那里卖的冰淇淋挺好吃的。下午去了明洞那边，还去了两个免税店，买了很多化妆品。晚上在乐天世界玩，可惜的是因为很多有趣的项目都要排队，而且要排1个多小时，所以也没有玩到项目。估计也是因为中秋节，韩国放假，很多本地人也来到乐天世界玩。</p><p>个人总的感觉就是，去了解一下韩国文化什么的还可以，男生的话过去估计都会觉得很无聊。女生过去就是买买买。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paw</title>
      <link href="/2016/07/24/Paw/"/>
      <url>/2016/07/24/Paw/</url>
      
        <content type="html"><![CDATA[<p>因为个人在产品研发中，既要负责服务端API的研发工作，同时也要负责iOS端的研发工作，所以有时候写完服务端API，马上就用iOS对接，同时判断API有没有问题。</p><p>不过随着团队人员的扩张，新来的客户端同事，不懂服务器端的相关技术，导致服务端API在写完后，需要进行简单的测试，保证服务器端能够顺利调用(服务端API总是会在客户端调用之前完成，并且可能客户端要过较久一段时间才会调用，为了能让负责服务端的同事自测API的状况，我曾考虑服务端的逻辑部分使用单元测试来进行处理)，我找到了Paw这款软件，它号称是Mac最先进的HTTP客户端。</p><p><a href="https://luckymarmot.com/zh-hans/paw" target="_blank" rel="noopener">Paw</a>除了友好，易操作的界面之外。还有个强大的功能就是可以生成客户端请求代码，支持C#、Python、Swift、Objective-C(AFNetworking，NSURLSession)等等。更支持请求动态值，从之前的响应中获取数据，例如身份验证令牌、计算后的哈希值、签名、测试用的随机数，做一些数学运算，或者任何您想做的。</p><p>官网官网价格为49.99刀，不过在这里我推荐<a href="https://item.taobao.com/item.htm?spm=a1z10.4-c.w4004-11449138832.26.3syAj4&amp;id=45684786090" target="_blank" rel="noopener">数码荔枝</a>，99 RMB即可入手，实在是超级划算。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 小工具 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一大早被DDoS。。。。。</title>
      <link href="/2016/07/03/%E4%B8%80%E5%A4%A7%E6%97%A9%E8%A2%ABDDoS%E3%80%82%E3%80%82%E3%80%82%E3%80%82%E3%80%82/"/>
      <url>/2016/07/03/%E4%B8%80%E5%A4%A7%E6%97%A9%E8%A2%ABDDoS%E3%80%82%E3%80%82%E3%80%82%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>今天早晨正在睡梦中，一阵手机震动将我摇醒。迷迷糊糊的看了下发现是产品经理打来的电话，心想这么早，莫非服务器出问题了？不出所料，产品经理告知目前我们服务器访问不了了，最大的客户正在投诉。</p><p>这时我脑袋已清醒，正在飞速的思考——服务器突然访问不了，难道服务进程挂了？同时立马摸出电脑，远程登录服务器，查看服务——正常，查看数据库服务——正常，查看系统日志——无异常。o(╯□╰)o，立马重启服务，再试，没有效果。这时心中突然有了不好的预感，难道被DDoS了？查看阿里云控制台，果然不出所料，DDoS攻击触发了流量清洗(流量清洗指过滤掉异常流量，保证服务器的正常运行。当然阿里云的流量清洗估计因为算法问题，将我们的正常访问也清洗掉了)，APP的请求都被阿里云重定向了。</p><p>当下联系阿里云客服，客服告知目前的情况有两个选择，1.购买阿里云高防服务。2.等攻击结束，自行恢复。<br>看了下阿里云的高防服务价格，WTF？，最最便宜8800每月。。。。。。</p><p>攻击30分钟后结束，流量清洗关闭，服务器也恢复了正常。不得不说因为DDoS攻击的成本低，效果显著，现在已经成为普遍的攻击手段。在DDoS的防范上，成本确实很高，在遭受攻击的时候，完全不知道能做什么。而实际上确实我们什么也做不了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> DDoS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建Event</title>
      <link href="/2016/05/22/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAEvent/"/>
      <url>/2016/05/22/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAEvent/</url>
      
        <content type="html"><![CDATA[<p>因项目中有一个日程功能，个人认为和iOS中日历的事件(还有另一个东西叫提醒)挺相似的，于是决定将其数据和与系统日历事件同步，这样可以利用系统日历事件的提醒功能。</p><pre>**日历事件：**主要是时间为线索，将所有事件组织起来，事件或者说是行程安排是有时间先后顺序的。**提醒事项：**功能和日历中的添加事件很相似，最大的不同在与条目的组织形式。提醒事项里的条目不再以时间顺序排列，而是可以对条目性质进行分类，如分成生活、工作、学习等等。或者也可以根据项目进行分类，且条目可以设置紧急程度。**总结：**日历事件适合安排行程，提醒事项适用于项目的任务管理。</pre><ul><li>引入EventKit.framework。</li><li>创建EKEventStore<br><pre>EKEventStore用于从用户的日历数据库中获取、创建、编辑和删除事件。</pre><script src="https://gist.github.com/yuxiangq/0741cd8a55832830e252cf12696699ad.js"></script></li><li>创建CalendarEvent<script src="https://gist.github.com/yuxiangq/f24490a827342d04f12138c9d8e5c22c.js"></script></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Eventkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC中的泛型</title>
      <link href="/2016/04/19/OC%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
      <url>/2016/04/19/OC%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在重构项目，决定将去年WWDC中讲到的OC新特性，泛型支持应用到项目中来。其实这是我一直很期待的一个特性，毕竟在做.Net的时候，泛型可是嚎嚎的好用。但是在此之前OC是不支持泛型的，那个时候使用NSArray等集合数据结构进行数据传递时，必须对业务有一定熟悉，或者变量命名相对规范些，不然很容易搞不清楚里面存储的是什么数据(Model)。</p><p>泛型示例如下：</p><script src="https://gist.github.com/yuxiangq/60e1e8d8d8c32734e5b2aa31d2166873.js"></script><p>这里要注意的是，编译器只会产生警告，不会报错，并且程序也是可编译通过运行的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蚂蚁金服技术开放日活动小记</title>
      <link href="/2016/03/13/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E6%8A%80%E6%9C%AF%E5%BC%80%E6%94%BE%E6%97%A5%E6%B4%BB%E5%8A%A8%E5%B0%8F%E8%AE%B0/"/>
      <url>/2016/03/13/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E6%8A%80%E6%9C%AF%E5%BC%80%E6%94%BE%E6%97%A5%E6%B4%BB%E5%8A%A8%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>今天很开心的参加了蚂蚁金服技术开放日活动，非常感谢技术专家们的分享。这次活动的干货确实挺多的，在这里我简单总结下自己的收获。</p><p><strong>团队拥有统一的技能</strong></p><p>在团队建设方面，我受到的第一个启发就是让团队成员拥有统一的技能，这样能让整个团队变得更加高效。尤其是团队较小的时候，拥有更多的复合型人才，是团队的核心竞争力。这也是我后续团队建设工作中的重点。</p><p><strong>DTP模型</strong> </p><p>这是一个我在参加活动之前没有听过的名词，它表示分布式事务模型。分布式事务简单说来就是，跨越多个资源的保证数据一致性。</p><p>其中，X/Open DTP是X/Open这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口。</p><pre>X/Open DTP 定义了三个组件： AP，TM，RM。*AP(Application Programma)：应用程序，可以理解为使用DTP的程序。**RM(Resource Manager)：资源管理器，应用程序通过资源管理器对资源进行控制。**TM(Transaction Manager)：事务管理器，负责协调和管理事务，提供给AP应用程序编程接口以及管理资源管理器。* </pre><p><strong>最终一致性</strong></p><p>我们在处理分布式事务的时候，最重要的就是保证数据的一致性。但是有些时候，我们却不得不在一致性上做出妥协。当然，在一致性上进行妥协，并不是完全不管数据的一致性，否则数据是混乱的，所以我们要保证数据的最终一致性。</p><p><strong>蓝绿发布</strong></p><p>这个是我一致想在现有产品中做到的，但是在这之前不知道有这么一个专有名词。蓝绿发布的意义在于，整个发布过程中，用户不会感受到任何宕机或者服务重启。</p><p><strong>灰度发布</strong></p><p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FunnelChartView漏斗控件</title>
      <link href="/2016/03/05/FunnelChartView%E6%BC%8F%E6%96%97%E6%8E%A7%E4%BB%B6/"/>
      <url>/2016/03/05/FunnelChartView%E6%BC%8F%E6%96%97%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>FunnelChartView是我为满足产品需求编写的一个简单的漏斗图表控件，主要用来展示销售漏斗，使用CoreGraphics绘制而成。</p><p>一直在纠结，这个控件的数据应当采用什么结构传才好。于是做了两个初始化接口：</p><ul><li>传一个FunnelChartModel列表。</li><li>传一个NSNumber列表，一个UIColor列表。</li></ul><p>个人感觉还是似有不妥，另外控件的整体效果还不够精致，还需要更多的打磨。</p><p>具体效果如果：<br><img src="https://raw.githubusercontent.com/yuxiangq/FunnelChartView/master/ScreenShots/Simulator%20Screen%20Shot%20Mar%203%2C%202016%2C%2022.50.16.png" alt=""></p><p>使用示例：</p><script src="https://gist.github.com/yuxiangq/2ff50e3cfd49c0568844.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 自定义控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离职季感悟</title>
      <link href="/2016/02/26/%E7%A6%BB%E8%81%8C%E5%AD%A3%E6%84%9F%E6%82%9F/"/>
      <url>/2016/02/26/%E7%A6%BB%E8%81%8C%E5%AD%A3%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p>又到了一年一度的离职旺季，不幸的是我的项目组也有两位主力离职。作为他们的Leader，我虽然感到遗憾，但也挺他们感到高兴。遗憾的是，他们不能再陪着整个团队成长，同时因为他们的离开，我们产品这一两个月的研发进度也会受到影响。高兴的是，他们将去一个更高的平台磨练自己。</p><p>今天有个同事面试回来告诉我，面试官问的很多问题，他都没有料到，都比较底层。就我们的产品开发来说，几乎不会用到。他回顾了一下这两年在团队中的开发情况，自己一手做出来的产品，在技术上真没有什么可以骄傲的地方，大部分时间其实就是处理业务逻辑，可以看出他比较失落。我得承认，我们做得这个产品确实不够高大上，技术上可以说都是很成熟的技术，技术门槛低。回头整理自己的知识体系，我也发现在产品的某个时间点开始，我们更多的时间是在处理业务了，初期开荒阶段，各种技术尝试，封装常用库，架构等等。产品进入平稳期后，更多的业务需求占据了开发日程，留给尝试各种技术的空间慢慢变少，自然会觉得自己的技术好像在某个时间点有了停滞。</p><p>作为一名技术人，都梦想着自己能成为大牛，我也在向这这个方向努力。所以一直在尽量利用业余时间，尝试一些产品中没有使用的东西，或者新的技术。最近这段时间，自己也有迷惘，或许就是进入了瓶颈期。是的，每个IT人都会有瓶颈期，他们面对的方式也不一样。有得人在技术上遇到瓶颈期，于是就会选择转向别的方向，比如管理。有的人会慢慢的被磨掉耐心，怀疑自己的能力，从而变得平庸。有的人则会在某个时候，突破瓶颈，迎来技术的再一次快速提升。我是希望自己能迎来又一波技术的快速提升，从而实现自己做出一款牛B的梦想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串行异步网络请求的简单实现</title>
      <link href="/2016/02/21/%E4%B8%B2%E8%A1%8C%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2016/02/21/%E4%B8%B2%E8%A1%8C%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在项目中遇到这样一个场景 —— 客户端数据需要一条一条的上传给服务器，且上一条上传成功，才开始上传下一条，如果上一条上传失败，则整个上传终止。实质上这就是一个串行异步网络请求的过程(串行执行一个异步任务序列)。</p><p><strong>方案一</strong></p><p>使用递归实现，网络请求部分我这里使用AFNetworking，当然也可以用其他的库。</p><script src="https://gist.github.com/yuxiangq/6bb4cf904a5e22b1187c.js"></script><p><strong>方案二</strong></p><p>使用NSOperationQueue，网络请求部分使用NSURLSession，自然也可以使用AFNetworking。</p><script src="https://gist.github.com/yuxiangq/5a6fda885689df3ef4e6.js"></script><p><strong>方案三</strong></p><p>使用AFNetworking中，AFURLConnectionOperation的方法</p><p><pre><code></code></pre></p><ul><li>(NSArray <em> )batchOfRequestOperations:(NSArray </em> )operations<br>progressBlock:(void ( ^ )(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock<br>completionBlock:(void ( ^ )(NSArray * operations))completionBlock<br><br>配合NSOperationQueue来进行，可以看做方案二的加强版。这里就不提供示例代码了。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 异步 </tag>
            
            <tag> 串行请求 </tag>
            
            <tag> 请求队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>襄阳出差</title>
      <link href="/2016/01/24/%E8%A5%84%E9%98%B3%E5%87%BA%E5%B7%AE/"/>
      <url>/2016/01/24/%E8%A5%84%E9%98%B3%E5%87%BA%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<p>今天襄阳出差，接近13个小时的火车。不得不说这是对我的一大挑战。</p><p>说起坐火车的记忆，我还停留在好几年前，那个时候是坐火车回重庆老家，那个时候还不用实名制买票，还有慢车一说（就是每个车站，无论大小都会停的车），小车站的检票也不是太严格。经常有没买票的人混上车，被发现了的话，就主动打扫车上卫生，列车员倒也乐意。</p><p>接近13小时的硬座，真是让人便秘（我是认真的o(╯□╰)o）。凌晨1点过的时候到了车站，打个车去酒店便呼呼大睡。</p><p>7点起床，吃了个牛肉面，味道和老家相比的话，牛油味儿更重，面更劲道。</p><p>客户那儿的培训，我主要参与答疑工作。不过对于国企的人员冗余，觉得比较蛋疼。一正职，两副职，三助理，真让人无语。客户对于同类软件比较有经验的，一针见血的指出了我们软件的不足，这也是不可辩驳的。</p><p>上午的工作完成后，下午去了趟古隆中。古隆中比较让人失望，没什么好看的。整个景区也挺冷清的，没什么人。走了一下午，小腿痛得不行。</p><p>晚上23点的火车，我们在火车站的德克士等了2个多小时。中间发生了一个小插曲，我一直问服务员有木有鸡米花，服务员说他们这叫魔法鸡块。买完之后我才想起，鸡米花是肯德基的o(╯□╰)o。</p><p>登上火车便是埋头就睡，11半的时候到达成都，结束了这次出差。</p><p>瞎扯吐槽完毕。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1601随笔</title>
      <link href="/2016/01/10/1601%E9%9A%8F%E7%AC%94/"/>
      <url>/2016/01/10/1601%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>将个人博客用hexo部署到github后还没写过东西，这里就简单整理下最近手上处理的事情。</p><p>工作上最近因为赶着发版，所以加班比较多，周一到周四都要加班到21点。新版本的进度不算乐观，原计划能在奔月20号发版，现在看来比较勉强。下周做完功能的话，实际上留给测试的时间不多，需要更慎重一点。新版的功能我个人还是挺期待的，虽然功能的完善程度不及竞争对手，但是我相信随着两到三个版本的迭代，我们将会走出一条更有特色的道路。</p><p>平时自己折腾的东西有点多，Sketch、Hexo、PMP、CRM理论都是最近在涉猎的。上周和前同事聊天，他目前已转iOS开发，他提到ReactiveCocoa和Masonry两个开源库。这两个库我较早以前就在技术博客上有所了解，不过一直没在生产环境中使用过。这次听朋友说这两个库非常好用，正巧最近在VFL上遇到不少坑，于是果断用Masonry布局，果然很爽，现在已经离不开它了。ReactiveCocoa我用在了自己的个人项目中，也非常不错，确定在公司项目中也是用它。</p><p>最近自己在折腾一个个人小项目，用来尝试一些新奇的想法，就写不说是什么了，等我写的差不多的时候再公布。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS实现判断程序关闭、关机的思路</title>
      <link href="/2015/10/25/iOS%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%85%B3%E9%97%AD%E3%80%81%E5%85%B3%E6%9C%BA%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/2015/10/25/iOS%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%85%B3%E9%97%AD%E3%80%81%E5%85%B3%E6%9C%BA%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>最近在研究竞品的时候，发现其实现了检测APP是否关闭，用户是否关机的功能。当然我们知道以iOS的情况来说，是没有API能直接做到的。不过简单想了想，觉得利用多种方式配合，或许我们还是可以「判断」关机和APP关闭的。</p><ol><li>APP使用心跳机制和服务器保持通信。</li><li>APP监听手机的网络状态变化，并将数据上传给服务器。</li><li>服务器定时利用Slient Remote Notifications判断APP是否有反应。</li></ol><p><strong>判断</strong></p><p>服务器发现客户端心跳不正常，判断是否有网络异常状态，如果有网络异常状态则判断为「网络异常」。<br>如果没有网络异常状态，则向APP发送Slient Remote Notifications，如果APP没响应，则判断为「关机」。<br>如果有响应，则判断为「APP关闭」</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UITableView实现下拉刷新</title>
      <link href="/2015/09/13/UITableView%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
      <url>/2015/09/13/UITableView%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>下拉刷新</strong>实在是很了不起得创意。目前几乎所有APP只要涉及刷新的功能，都会采用这种方式，这已经是刷新交互的标配。</p><p>在Github上有大量的开源组件能实现<strong>下拉刷新</strong>和<strong>上拉加载</strong>，在这里我推荐<strong><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a></strong>，它能帮我们很优雅的实现以上两种功能。</p><p>下拉刷新的原理，大家很容易理解，就是利用UITableView偏移到一定程度，然后调用刷新方法即可。但是有些童鞋可能发现了一个问题，就是UITableViewDelegate中并没有拖动相关的方法，这是怎么回事呢？其实那是因为UITableView本身继承自UIScrollView，所以我们只需要实现UIScrollViewDelegete中的- (void)scrollViewDidScroll:(UIScrollView * )scrollView方法即可。</p><p><pre><code><br>//只提供关键方法<br>-(void)p_InitUITableView<br>{<br>if(self.tableView==nil)<br>{<br>self.tableView=[UITableView alloc] init];<br>self.tableView.delegate=self;<br>self.tableView.datasource=self;<br>}<br>}<br>//拉动UITableView的时候会调用该方法<br>-(void)scrollViewDidScroll:(UIScrollView * )scrollView<br>{<br>//判断是否处于刷新状态<br>if(self.isLoading)<br>{<br>//获取实际内容的高度,及UITableViewCell集合的高度，包括超出屏幕部分。<br>float contentHeight=scrollView.contentSize.height;<br>//获取TableView的高度<br>float tableViewHeight=self.tableView.frame.size.height;<br>//获取展示内容的高度,如果内容高度大于UITableView高度，就以UITableView高度为准；<br>//如果内容高度小于UITableView高度，就以内容高度为准。<br>float displayHeight=contentHeight&gt;tableViewHeight?tableViewHeight:contentHeight;<br>//接下来我们需要计算，我们拉动UITableView的时候，我们的展示内容displayHeight偏移了多少。<br>//假设相对于displayHeight往上或往下偏移20%的距离及算触发刷新。<br>if ((displayHeight - scrollView.contentSize.height + scrollView.contentOffset.y) / displayHeight &gt; 0.2)<br>{<br>// 调用上拉加载方法，在这里可以处理一些刷新动画<br>}<br>//scrollView.contentOffset.y表示整个内容在y轴上的偏移量，下拉的时候内容是向y轴负方向移动<br>//所以计算的时候要取反<br>if (- scrollView.contentOffset.y / self.tableView.frame.size.height &gt; 0.2)<br>{<br>// 调用下拉刷新方法，在这里可以处理一些刷新动画<br>}<br>}<br></code></pre><br>另外我们在添加下拉刷新的箭头的时候，Header不要添加在TableViewHeader上，要添加在UITableView的subView中。否则Header会一直在顶端，不会被覆盖。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UITableView </tag>
            
            <tag> 下拉刷新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAPP将迎来一个好时代</title>
      <link href="/2015/08/29/WebAPP%E5%B0%86%E8%BF%8E%E6%9D%A5%E4%B8%80%E4%B8%AA%E5%A5%BD%E6%97%B6%E4%BB%A3/"/>
      <url>/2015/08/29/WebAPP%E5%B0%86%E8%BF%8E%E6%9D%A5%E4%B8%80%E4%B8%AA%E5%A5%BD%E6%97%B6%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<p>随着4G网络的普及，以及手机性能、浏览器性能的提升，WebAPP正迎来自己的时代。</p><p>想起2-3年前的时候，就有很多人在说WebAPP将崛起与NativeAPP平分秋色。但事实是WebAPP并没有真正占据一定份额。主要原因莫过于响应速度和体验远逊于NativeAPP，当然也有优化到极端的例子，效果可以说无限接近NativeAPP，但那毕竟是少数。大多数的WebAPP采用「JQueryMobile」、「SenchaTouch」等框架，在具体研发中遇到过的坑那是相当多，尝试过开发商业项目的童鞋应该心有余悸。</p><p>最近一年，4G网络的加紧推广及流量价格的降低，解决了WebAPP很大的一个短板，也让我们看到了WebAPP崛起的希望。其实移动网络的加速，对整个APP开发都是有益的，对于小团队来说，就不用将太多的精力投入到基础通讯的优化上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WebAPP </tag>
            
            <tag> 行业发展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机是如何定位的</title>
      <link href="/2015/06/19/%E6%89%8B%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E7%9A%84/"/>
      <url>/2015/06/19/%E6%89%8B%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>我们目前了解到的手机定位方式，主要有四种：GPS、A-GPS、Wi-Fi、基站定位。</p><h4 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h4><p>即全球定位系统，它是利用GPS定位卫星，在全球范围内实时进行定位、导航的系统。民用定位精度为10米左右，定位精度取决于上方遮盖物，周围环境，当地政策等。所以室内是无法使用GPS进行定位的。在空旷的地方GPS定位精度高于城市中。</p><p><em>优点:精度高、不依赖网络。</em></p><p><em>缺点:定位速度慢，因为GPS的使用需要搜索卫星，并且不同的设备，不同的环境搜索卫星的速度都会不一样。所以当需要快速定位，对位置精度要求不高的场景，GPS不是一个很好的选择。</em></p><pre><code>关于手机GPS和车载GPS速度的比较:GPS定位的时候是需要通过卫星的位置、用户到卫星的距离来确定用户的位置。而卫星在运行时轨道不可避免的会产生误差和变动，这就需要用户使用最新的卫星轨道参数来求得卫星位置，卫星的这些参数叫做星历。GPS定位的快慢，和获取星历的快慢，有直接关系。在有网络连接的情况下，手机可以从网络服务器下载星历，从而提高首次定位的速度(几秒到几十秒)，而没有网络的时候，手机GPS只能像车载GPS一样从卫星上下载星历，传输速率低很多，首次定位时长增加到2-5分钟。用户GPS设备，在长时间关闭(或丢失信号)后，星历可能发生较大变化，甚至完全不同，或者有些GPS设备没有关闭后存储星历的功能，就需要下载新的星历，这就是「冷启动」。而热启动就是短时间关闭或丢失信号之后再进行定位，星历可能只需要略加变动或没有变动，不需要花大量的时间下载星历，可以直接用存储的星历进行解算。</code></pre><h4 id="A-GPS-Assisted-GPS"><a href="#A-GPS-Assisted-GPS" class="headerlink" title="A-GPS(Assisted GPS)"></a>A-GPS(Assisted GPS)</h4><p>A-GPS（Assisted GPS：辅助全球卫星定位系统）是结合GSM/GPRS与传统卫星定位，利用基地台代送辅助卫星信息，以缩减GPS芯片获取卫星信号的延迟时间，受遮盖的室内也能借基地台讯号弥补，减轻GPS芯片对卫星的依赖度。简而言之，就是有网络辅助的GPS。</p><p>A-GPS解决方案的优势主要在其定位精度上，在室外等空旷地区，其精度在正常的GPS工作环境下，可达10米左右，堪称目前定位精度最高的一种定位技术。该技术的另一优点为：首次捕获GPS信号的时间一般仅需几秒，不像GPS的首次捕获时间可能要2～3分钟。</p><p><em>优点:定位速度快、精度高。</em></p><p><em>缺点:不支持室内定位、依赖网络。</em></p><h4 id="Wi-Fi定位"><a href="#Wi-Fi定位" class="headerlink" title="Wi-Fi定位"></a>Wi-Fi定位</h4><p>Wi-Fi定位的原理并不是很多人想的那样依靠IP地址定位，它实际是利用Wi-Fi信号来定位。当你的手机能收到某个Wi-Fi信号时，手机就会去服务器查找这个Wi-Fi信号的位置，然后再通过Wi-Fi信号强度进行纠正。比如在iOS中，系统就会提示用户，开启Wi-Fi以便获取更精确的位置信息。</p><pre><code>关于Wi-Fi信息的采集，Apple会使用专门的采集车，沿街道扫描Wi-Fi信号，并将Wi-Fi信号的强度、经纬度等相关信息上传到服务器。同时当我们的手机连接到某个Wi-F时i，手机系统也会记录下该Wi-Fi的相关信息，并尝试获取经纬度(例如通过基站定位)然后将其上传。百度地图、谷歌地图等地图相关的APP，差不多都有这样的采集措施。</code></pre><p><em>优点:可室内定位，速度较快，定位精度较高、不依赖网络。</em><br><em>缺点:定位精度稳定性不高</em></p><h4 id="基站定位"><a href="#基站定位" class="headerlink" title="基站定位"></a>基站定位</h4><p>基站定位技术一般应用于手机，它是通过电信移动运营商的网络(如GSM网)获取移动终端用户的位置信息的技术。<br>基站定位的大致原理为：移动电话测量不同基站的下行导频信号，得到不同基站下行导频的TOA(Time of Arrival，到达时刻)或TDOA(Time Difference of Arrival，到达时间差)，根据该测量结果并结合基站的坐标，一般采用三角公式估算法，就能够算出移动电话的位置。实际的位置估计算法要考虑多基站(3个或3个以上)定位的情况，一般而言，附近基站数目越多，定位精度越高。</p><p><em>优点：可以室内定位，定位速度快、不依赖网络。</em></p><p><em>缺点：定位精度受基站覆盖率影响，定位精度不稳定。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> GPS </tag>
            
            <tag> 定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记七</title>
      <link href="/2015/05/21/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
      <url>/2015/05/21/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h4 id="关于Swfit中的构造器"><a href="#关于Swfit中的构造器" class="headerlink" title="关于Swfit中的构造器"></a>关于Swfit中的构造器</h4><p><strong>构造器</strong>其实就是我们在其他语言中常说的<strong>构造函数</strong>。</p><pre>与Objective-C中**构造函数**不同的是，Swfit的**构造器**无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化(这个初始化过程包括为实例中属性值设置初始值等)。</pre><pre>当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观测器（property observers）。</pre>**构造器**的最简形式类似于一个不带任何参数的实例方法，以关键字*init*命名，例如：<pre><code>//在这里我们定义一个结构体struct test{var testNum:Doubleinit(){testNum=1.1}}//该结构体定义了一个不带参数的构造器，并且将属性testNum的值设置为1.1。</code></pre>你也可以在定义构造器时提供构造参数，为其提供定制化构造所需值的类型和名字。构造器参数的功能和语法跟函数和方法参数相同，例如：<pre><code>struct test{var testNum:Doubleinit(fromTestNum t:Double){testNum=t}}</code></pre><pre>跟函数和方法参数相同，构造参数也存在一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。所以在调用构造器时，主要通过构造器中的参数名和类型来确定需要调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名，就相当于在每个构造参数之前加了一个哈希符号。</pre>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义UITableViewCell，使用VFL布局</title>
      <link href="/2015/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89UITableViewCell%EF%BC%8C%E4%BD%BF%E7%94%A8VFL%E5%B8%83%E5%B1%80/"/>
      <url>/2015/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89UITableViewCell%EF%BC%8C%E4%BD%BF%E7%94%A8VFL%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>自定义UITableViewCell自动布局的文章网上又挺多的，但是大部分都是采用的xib进行布局，所以这一块其实水挺深的。经过自己的实践和不断的查找资料，终于实现了使用纯VFL布局，实现方式在这里和大家一起分享一下，<a href="https://github.com/yuxiangq/UITableViewCell4VFL/commits?author=yuxiangq" target="_blank" rel="noopener">Demo比较简单</a></p><ul><li><p>首先我们新建一个工程，命名为CustomCellWithVFLDemo，如下图所示：<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/CustomCellVFL/create_project_1.png" alt="image"><br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/CustomCellVFL/create_project_2.png" alt="image"></p></li><li><p>让我们的ViewController继承UITableViewController。继承UITableViewController能帮我们省不少事情。<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/CustomCellVFL/viewcontroller_uitableviewcontroller.png" alt="image"></p></li><li><p>新建CustomCell，我们在其中新建一个UILabel，叫contentLabel，用于展示文本数据并允许换行。</p><script src="https://gist.github.com/yuxiangq/96c5ffeb2ab9d718a33e.js"></script></li><li><p>为contentLabel设置约束，这里我们的约束可以看做Margin(5,5,5,5)。</p><script src="https://gist.github.com/yuxiangq/dc9faab124f1eedf82a8.js"></script></li><li><p>在ViewController中添加一个原型cell，动态计算高度的时候使用。</p><script src="https://gist.github.com/yuxiangq/6c282d9899fe28fe59e4.js"></script></li></ul><pre>涉及换行的UILabel，请一定要注意**preferredMaxLayoutWidth**属性的设置，否则换行会出问题。</pre>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> VFL </tag>
            
            <tag> UITableViewCell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2014总结</title>
      <link href="/2015/02/04/%E6%88%91%E7%9A%842014%E6%80%BB%E7%BB%93/"/>
      <url>/2015/02/04/%E6%88%91%E7%9A%842014%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2014已经结束了，在这元旦假期的最后一天，就让我来总结一下自己去年技术上的收获及见闻。</p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>去年我的主要角色是整个团队的iOS工程师及技术总负责人。当然同时还会兼职产品经理，运维等其他角色o(╯□╰)o。</p><h2 id="VFL"><a href="#VFL" class="headerlink" title="VFL"></a>VFL</h2><p>首先是学会使用了VFL，真是布局神器，强烈推荐。为此我将产品中大部分的布局都使用VFL进行了重写。这感觉，谁用谁知道。</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>今年初的时候产品不再支持iOS4(我的决定^_^)，于是启用了ARC。这感觉，谁用谁知道</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a><a href="https://github.com/yuxiangq" target="_blank" rel="noopener">Github</a></h2><p>在上面发现了不少优秀的代码，自己也参与了一些。这才是程序员的SNS。</p><h3 id="XHImageViewer"><a href="#XHImageViewer" class="headerlink" title="XHImageViewer"></a><a href="https://github.com/JackTeam/XHImageViewer" target="_blank" rel="noopener">XHImageViewer</a></h3><p>一个图片查看控件，支持图片缩放。我为其添加了Block支持。目前正在研究用其查看超大图片。</p><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p>将产品的网络请求全部替换为AFNetworking 2.0，因为前期对网络请求层进行了一次封装，所以替换起来很顺利。</p><h3 id="NumberTextField"><a href="#NumberTextField" class="headerlink" title="NumberTextField"></a><a href="https://github.com/yuxiangq/NumberTextField" target="_blank" rel="noopener">NumberTextField</a></h3><p>自己写的一个只允许输入数字的控件，在新的一年中还需要将其完善。</p><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><p>一个优秀的第三方库管理工具，今年初的时候产品的大部分第三方库已经用其管理。</p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>Mac下的优秀的快速启动工具，目前我已经是它的重度用户。配合workflow，实在是神器。自己也在用Python为其编写插件。</p><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>有条不紊的学习中，因为自己对C#的熟悉，所以很多Swift的新特性个人感觉并不是很惊艳。</p><h1 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h1><p>去年写.Net的时间较少，更多的是在技术大方向上的把握。</p><h2 id="WebAPI"><a href="#WebAPI" class="headerlink" title="WebAPI"></a>WebAPI</h2><p>一直在计划将服务器框架由WCF替换为WebAPI，在年中的时候进行了框架搭建，可惜的是因为产品功能迭代较快，没有时间完成框架替换。</p><h2 id="Nuget"><a href="#Nuget" class="headerlink" title="Nuget"></a>Nuget</h2><p>在新服务器工程中使用的引用管理工具。</p><h2 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a><a href="https://github.com/yuxiangq/dapper-dot-net" target="_blank" rel="noopener">Dapper</a></h2><p>一个轻量级高效率的ORM框架，重要的是针对MySQL的支持同样优秀。相较于EF的繁琐，对于习惯使用ADO.NET的朋友来说，该框架实在是太合适了。</p><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>14年阅读了挺多经典的书籍，还有部分书没来得及读。除了技术相关书籍还读了部分马伯庸的小说，真的非常好。</p><h2 id="Effective-Objective-C-2-0"><a href="#Effective-Objective-C-2-0" class="headerlink" title="Effective Objective-C 2.0"></a><a href="http://book.douban.com/subject/21370593/" target="_blank" rel="noopener">Effective Objective-C 2.0</a></h2><p>一本很棒的书，讲了很多有关Objective-C的技巧，不过翻译挺烂的。</p><h2 id="文明之光"><a href="#文明之光" class="headerlink" title="文明之光"></a><a href="http://book.douban.com/subject/25902942/" target="_blank" rel="noopener">文明之光</a></h2><p>吴军老师的书，作为一名IT工作者，开阔的视野是必不可少的，推荐阅读。</p><h2 id="ASP-NET-Web-API-2框架揭秘"><a href="#ASP-NET-Web-API-2框架揭秘" class="headerlink" title="ASP.NET Web API 2框架揭秘"></a><a href="http://book.douban.com/subject/25923644/" target="_blank" rel="noopener">ASP.NET Web API 2框架揭秘</a></h2><p>讲解WebAPI的书，目前主要当词典用。</p><h2 id="菊与刀"><a href="#菊与刀" class="headerlink" title="菊与刀"></a><a href="http://book.douban.com/subject/1022238/" target="_blank" rel="noopener">菊与刀</a></h2><p>从美国人的角度来看日本的书。</p><h2 id="死于技术：索尼衰亡启示"><a href="#死于技术：索尼衰亡启示" class="headerlink" title="死于技术：索尼衰亡启示 "></a><a href="http://book.douban.com/subject/25835910/" target="_blank" rel="noopener">死于技术：索尼衰亡启示 </a></h2><p>索尼确实已经衰落了，卖掉了经典的VAIO，这本书全面的剖析了索尼衰落的原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记六</title>
      <link href="/2015/02/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
      <url>/2015/02/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<p>Swift中的枚举拥有很棒的特性，至少以前我是没有接触过的。</p><p>####枚举语法####<br>使用<strong>enum</strong>关键字，并将其整个定义放在大括号内：</p><pre><code>enum demo{//定义枚举相关类容}</code></pre>假设我们定义指南针的四个方向：<pre><code>enum CompassPoint {case Northcase Southcase Eastcase West}</code></pre>一个枚举中被定义的值是枚举的**成员值**(或者**成员**)。**case**关键字表明新的一样关键字被定义。多个成员值也可以出现在同一行上，用逗号隔开：<pre><code>enum CompassPoint {case North,South,East,West}//使用方法var directionToHead = CompassPoint.WestdirectionToHead = .North</code></pre><blockquote><p>注意：<br>不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的CompassPoints例子中，North，South，East和West不是隐式的等于0，1，2和3。相反的，这些不同的枚举成员在CompassPoint的一种显示定义中拥有各自不同的值。</p></blockquote><p>####相关值####<br>Swift的枚举可以存储任何类型的相关值，如果需要的话每个成员的数据类型是可以不同的。</p><p>比如我们可以定义两种商品条码的枚举：</p><p><pre><code><br>enum Barcode {<br>case UPCA(Int, Int, Int)<br>case QRCode(String)<br>}<br></code></pre><br>然后可以使用任何一种条码类型创建新的条码：</p><p><pre><code><br>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)<br>productBarcode = .QRCode(“ABCDEFGHIJKLMNOP”)<br>//使用Switch-case<br>switch productBarcode {<br>case .UPCA(let numberSystem, let identifier, let check):<br>println(“UPC-A with value of (numberSystem), (identifier), (check).”)<br>case .QRCode(let productCode):<br>println(“QR code with value of (productCode).”)<br>}<br></code></pre></p><p>####原始值####<br>作为相关值的替代，枚举成员可以被默认值（称为原始值）预先填充，其中这些原始值具有相同的类型。</p><p>这是一个枚举成员存储原始ASCII的例子：</p><p><pre><code><br>enum ASCIIControlCharacter: Character {<br>case Tab = “\t”<br>case LineFeed = “\n”<br>case CarriageReturn = “\r”<br>}<br></code></pre><br>原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。当整型值被用于原始值，如果其他枚举成员没有值时，它们会自动递增。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pocket、Instapaper、Readability的比较</title>
      <link href="/2015/01/25/Pocket%E3%80%81Instapaper%E3%80%81Readability%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2015/01/25/Pocket%E3%80%81Instapaper%E3%80%81Readability%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>在接触「稍后读」软件之前，我一直是使用Evernote来保存暂时无法阅读的文章。</p><p>大概是在两年前，我使用了第一款稍后读类的软件。当时自己入手了一台TouchPad(现在想起来相当后悔没有入手iPad啊)，刷成Android后主要用来看电子书和新闻，还用它在公司内部分享上查看演讲提纲(逼格很高啊)。这款APP是由原淘宝工程师开发的一款软件，叫<a href="http://www.udee.cn/" target="_blank" rel="noopener">uDee云阅读</a>。貌似已经挂了，官网已经变成建站系统了o(╯□╰)o。相关的介绍可以看这里<a href="http://www.36kr.com/p/99352.html" target="_blank" rel="noopener">36kr关于uDee云阅读的介绍</a>。</p><p>后来我入手了The New iPad，TouchPad就送给老爸看电影了。在iOS上我开始使用<a href="https://getpocket.com/" target="_blank" rel="noopener">Pocket</a>，那个时候还叫Read it later。用了一段时间后发现Pocket对CocoaChina支持不是很好，只能抓取到标题，查看内容的时候还得跳转到原网页，实在是麻烦，于是开始寻找其他类似产品。</p><p>某天在朋友手机上看到<a href="https://www.instapaper.com/" target="_blank" rel="noopener">Instapaper</a>，于是果断收了它(当时还是收费的)，完美支持CocoaChina，而且Instapaper的图标也比Pocket好看，所以开始同时使用二者，Pocket主力，Instapaper辅助。</p><p>不久入了Reeder，配合着两大神器，让我阅读了不少好文。但是Reeder也无法完整显示CocoaChina的内容，每次阅读的时候我都要先保存到Instapaper，实在是麻烦。后来无意中点了一下内容上方的小板凳图标，发现竟然将内容完整的显示出来了。后来知道了那是<a href="https://www.readability.com/" target="_blank" rel="noopener">Readability</a>，果断入手。</p><p>于是三大稍后读神器都被我凑齐了。用了一段时间后有些感悟，想和大家一起分享。</p><p><strong>Pocket</strong></p><p>我用得最久的稍后读类APP。 支持Chrome插件，通过插件保存网页。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20%E5%88%97%E8%A1%A8.PNG" alt="image"><br>文章列表界面清爽简洁，是我喜欢的风格。在列表界面提供搜索栏，很方便。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20%E8%8F%9C%E5%8D%95.PNG" alt="image"><br>软件的层级架构采用抽屉式结构，给了内容更多的展示空间。同时设置里面提供深色主题，方便夜晚阅读。唯一的遗憾是主题颜色不支持自动切换。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20%E7%BD%91%E9%A1%B5.png" alt="image"><br>Web端配色和APP保持一致，简洁不失优雅。并且Web端提供平铺和列表两种展示方式。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Pocket%20Mac.png" alt="image"><br>Pocket也是三款软件中唯一有Mac客户端的。</p><p><strong>Instapaper</strong></p><p>个人认为是最精致的稍后读类APP。利用JS脚本保存内容，不支持浏览器插件。需要占用一个标签栏位置，这是让我很不爽的地方。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Instapaper%20%E5%88%97%E8%A1%A8.PNG" alt="image"><br>文章列表简洁，整个界面更偏平，可惜的是不支持搜索。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Instapaper%20%E8%8F%9C%E5%8D%95.PNG" alt="image"><br>菜单仍然是抽屉式结构，搜索功能隐藏在了这里。其他东西和Pocket大同小异。同时支持深色主题(目前包含四款主题)，更令人欣喜的是，Instapaper可以根据您的位置(需要用到GPS)和日落时间，自动调整主题的颜色。这真的是非常棒的功能。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Instapaper%20Web.png" alt="image"><br>Web端的整体布局和APP差异不大，唯一的变化是将搜索栏放到了列表上。</p><p><strong>Readability</strong></p><p>我的感觉是抓取能力最强的了，但是界面不讨个人喜欢。支持Chrome插件。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Readability%20%E5%88%97%E8%A1%A8.PNG" alt="image"><br>支持搜索及分类，较Instapaper和Pocket都更强大，可以说是结合了二者的有点。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/readability%20%E8%8F%9C%E5%8D%95.PNG" alt="image"><br>同样是抽屉式侧拉菜单o(╯□╰)o，非常简洁，另外我不是很喜欢那种全红的背景。</p><p><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/Pocket%E3%80%81Instapaper%E3%80%81Readability%E6%AF%94%E8%BE%83/Readability%20Web.png" alt="image"><br>整体布局和APP类似，可惜的是没有了搜索功能。</p><p><strong>PS:以上就是我使用了三款APP后的一些浅薄看法。其实说起来它们对于我来说，都有一个很致命的缺点。就是对于代码块的处理都不尽如人意。本来文章中排版很舒服的代码，经过它们处理后就和普通文本混杂在一起，实在是一件很头痛的事情，希望能有一款稍后读类的APP能针对程序员定制。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> App比较 </tag>
            
            <tag> 稍后读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumberTextField</title>
      <link href="/2015/01/12/NumberTextField/"/>
      <url>/2015/01/12/NumberTextField/</url>
      
        <content type="html"><![CDATA[<h1 id="NumberTextField"><a href="#NumberTextField" class="headerlink" title="NumberTextField"></a><a href="https://github.com/yuxiangq/NumberTextField" target="_blank" rel="noopener">NumberTextField</a></h1><p>这是我做的一个只能输入数字的控件。<br>可以限制输入的数字长度及小数点位数。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><script src="https://gist.github.com/yuxiangq/71a2ac1dabac7b4fa556.js"></script></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>去除数字前多余的0。例如，输入000123，当控件失去焦点，或者通过text获取值的时候，数字会被处理为123。<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/before.png" alt="image"><br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/after.png" alt="image"></p></li><li><p>小数自动补0。例如，输入.123，当控件失去焦点，或者通过text获取值的时候，数字会处理为0.123。<br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/dotbefore.png" alt="image"><br><img src="https://raw.githubusercontent.com/yuxiangq/articlescreenshots/master/NumberTextField/dotafter.png" alt="image"></p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><pre><code><br>-(NSString*)trimText;<br></code></pre><br>调用该函数可以直接获取经过处理的数字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 自定义控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记五</title>
      <link href="/2015/01/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
      <url>/2015/01/01/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的定义及调用"><a href="#函数的定义及调用" class="headerlink" title="函数的定义及调用"></a>函数的定义及调用</h1><p>我们使用func关键字来定义函数:</p><pre><code>func test( / * 这里是函数参数，通常如此定义  parameter:String * / )->String{return "test"}test() //调用函数</code></pre><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h1><p>给函数的参数定义默认值的方式和C#是一样的:</p><pre><code>func test(s:string= "defaultValue")->String {return s;//如果s没有传值，则会返回defaultValue}</code></pre><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>用来输入不确定数量的参数，但是参数的类型必须一致:</p><pre><code>func test(numbers:Double...)->Double {var total: Double = 0for number in numbers {total += number}return total}</code></pre>**注意:一个函数至多能有一个可变参数，而且它必须是参数表中最后的一个。这样做是为了避免函数调用时出现歧义。**# 常量参数和变量参数这是要注意的是，函数中默认的参数为常量参数是不可以被重新赋值的。变量参数则需要显示定义。<pre><code>func test(s:String)->String{s="test" //这里会报错，参数s为常量参数，不能被重新赋值return s}func test(/ * 显示定位为变量 * /var s:String)->String{s="test" //正常return s}</code></pre>**注意： 对变量参数所进行的修改在函数调用结束后便消失了，并且对于函数体外是不可见的。变量参数仅仅存在于函数调用的生命周期中。**# 输入输出参数这个和C#中的**ref,out**是类似的。如果你需要一个参数能在函数体内被修改，并且在函数调用结束后修改仍然存在，就需要使用**inout**关键字来定义参数。<pre><code>//交换两个变量的值func swapTwoInts(inout a: Int, inout b: Int) {let temporaryA = aa = bb = temporaryA}</code></pre><h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>函数其实就是C#中的委托类型，也就是我们所说的函数指针。当然它相较于函数指针是类型安全的。</p><p><pre><code><br>func addTwoInts(a: Int, b: Int) -&gt; Int {<br>return a + b<br>}</code></pre></p><p>var mathFunction: (Int, Int) -&gt; Int = addTwoInts //mathFunction就是指向addTowInts函数的变量<br><br>如果我们要用一个变量来表示addTowInts这个函数，那么这个变量的类型就是<strong>(Int, Int) -&gt; Int</strong>，可以读作“这个函数类型，它有两个 Int 型的参数并返回一个 Int 型的值。”。<br>函数类型也是可以作为函数参数或函数返回值的。</p><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>默认情况下，嵌套函数是对外界不可见的，但是可以被他们封闭函数（enclosing function）来调用。一个封闭函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swfit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lock，一款有趣的应用</title>
      <link href="/2014/12/19/Lock%EF%BC%8C%E4%B8%80%E6%AC%BE%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2014/12/19/Lock%EF%BC%8C%E4%B8%80%E6%AC%BE%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>今天发现了一款有趣的应用，名字叫<a href="http://www.nearlock.me/" target="_blank" rel="noopener">Near Lock</a>。它有Mac版和iPhone版，二者是配合使用的。</p><p>它能让我们优雅的通过iPhone来解锁Mac。你只需要将iPhone带在身上，当你靠近自己的Mac的时候，它就是解锁状态，当你离开Mac的时候它又会自动锁上。</p><p>Pro版在中国区市场是25块，它能在后台运行。</p><p>经过我的体验，距离设置在2米左右比较合适。如果使用默认的1米，当手机刚连接上的时候，蓝牙测距不是很稳定，会在1米 ~ 2米直接跳动，导致一会儿锁屏，一会儿解锁。另外如果离开电脑时间较长再回来的话，蓝牙连接有很大的几率连接不上，希望以后的版本会有所改进。总的来说还是一款很不错的软件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UICollectionViewController的用法</title>
      <link href="/2014/12/14/UICollectionViewController%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2014/12/14/UICollectionViewController%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>UICollectionView和UICollectionViewController是iOS6中新增加的控件，主要用于复杂的布局。你可以简单的把它理解为Grid。<br>在最近的版本中，我在做表单界面的时候，放弃了UITableViewController，改用UICollectionViewController来进行布局，个人感觉挺好用的，在这里我简单给大家分享一下UICollectionViewController的用法。</p><p><strong>首先请大家注意的是，记得为UICollectionView的collectionViewLayout属性设置UICollectionViewLayout的子类。否则是会报错的。</strong></p><p>UICollectionView的使用方式与UITableView相比没有什么区别，都是DataSource为View提供数据源，告诉View要显示什么东西以及如何显示他们，Delegate提供一些样式的小细节及用户交互的响应。</p><p><strong>初始化UICollectionView</strong></p><p><script src="https://gist.github.com/yuxiangq/93fdc5d139747b410488.js"></script><br><strong>UICollectionViewDataSource回调方法</strong></p><p><script src="https://gist.github.com/yuxiangq/0c5aa8c4dd9ebc97047a.js"></script><br>以上三个方法都是UICollectionViewDataSource的基本方法，这些方法在UITableViewDataSource中也是有的，所以使用起来难度不大。<br>另外我们需要注意的是控制Cell尺寸的方法并不在UIcollectionViewDelegate的回调中，而是在UICollectionViewDelegateFlowLayout中</p><pre><code>- (CGSize)collectionView:(UICollectionView * )collectionView layout:(UICollectionViewLayout* )collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath * )indexPath;</code></pre><p>关于UICollectionView中的Supplementary Views和Decoration Views我还没有用到。目前了解到的是Supplementary Views类似UITableView中的Header和Footer。Decoration Views用作背景展示。<br>因为UICollectionView比UITableView复杂得多，所以它的布局样式并不是通过Style来改变，而是通过UICollectionViewLayout，这也是UICollectionView的精髓所在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UICollectionViewController </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何学习一门新语言</title>
      <link href="/2014/12/05/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E8%AF%AD%E8%A8%80/"/>
      <url>/2014/12/05/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E6%96%B0%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，我们肯定会在必要的时候学习一门新的编程语言，这个时候好的学习方法会帮助我们节省很多时间，在这里谈谈我的学习方法。</p><p>####快速了解语法####<br>我通常会快速了解该门语言的语法，并将其和已学会的语言进行比较。比如我在学习Objective-C的时候就是将其和C#进行比较，思考两者的差异。<br>C#中的委托，在Objective-C中有什么可以实现？<br>C#中的泛型，Objective-C中有吗？<br>如何实现单例？<br>C#中的拉姆达表达式，Objective-C有吗？<br>等等，等等。</p><p>####写Demo练习####<br>实际的练习也是必不可少的。可以通过很多小项目和算法来练习自己对新语言掌握的程度。比如写一个简单的计算器。</p><p>经历了以上两部分，我们就能较好的在实际项目中使用新语言了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VFL布局学习</title>
      <link href="/2014/12/04/VFL%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2014/12/04/VFL%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>随着iPhone6及iPhone6+的发布，适配大屏幕也提上了日程。有些童鞋习惯用xib配合iOS6时出现的autolayout进行界面的布局，但是我个人觉得xib实在是有点难用，特别是在macbook的小屏幕上，觉得xib要配一个大屏幕用起来才爽。还有就是用过Visual Studio的可视化编程后，始终觉得xib的易用性不够好。大屏幕又不得不适配，怎么办呢，如果像以前那样算坐标的话倒是也行，但毕竟比较繁琐，又不想用xib，那就只好用<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage/VisualFormatLanguage.html" target="_blank" rel="noopener">Visual Format Language</a>。</p><p>初看VFL，肯定觉得莫名奇妙，给我的感觉就像第一次看到正则表达式的时候一样(个人以为VFL可比正则表达式简单多了)。不过VFL的符号比较少且简单，用2-3次估计就都记住了，大家可以看看上面官方文档的链接。我在这里简单介绍一下常用的符号表示的意思(我会用<strong>方引号(「」)</strong>将符号括起来)：</p><p><strong>「V:」</strong>或<strong>「H:」</strong>分别表示垂直方向和水平方向。</p><p><strong>「|」</strong>表示父视图。</p><p><strong>「[loginButton]」</strong>表示一个名叫loginButton的视图</p><p><strong>「H:|-10-[loginButton]-10-|」</strong> 表示 <strong>loginButton在水平方向左边距离父视图10，右边距离父视图也是10</strong>。</p><p><strong>「H:|-15-[buttonOne(80)]-5-[buttonTwo(90)]」</strong> 表示<strong>buttonOne在水平方向左边距离父视图是15，本身宽度是80，右边与buttonTwo的距离为5，buttonTwo的宽度为90</strong>。</p><p>以上这些就是常用的符号，掌握着几种最基本的也足够我们进行大部分的界面布局了。<br>接下来我们简单写一个例子。我们假设大家都是有一定iOS编程基础的童鞋，所以怎么创建Single View Application这种事情就不罗嗦了，我们假设大家已经创建好了，接下来的我们将在View上添加一个Button，并用VFL来控制它的位置和大小。</p><p><pre><code><br>//我们在这里创建一个Buton<br>-(void)viewDidLoad<br>{<br>[super viewDidLoad];<br>UIButton* button=[[UIButton alloc] init];</code></pre></p><p>//切记在这里一定要将该属性设置为NO，否则View<br>//会按照以往的autoresizingMask进行计算。<br>button.translatesAutoresizingMaskIntoConstraints=NO;</p><p>[button setTitle:@”测试” forState:UIControlStateNormal];<br>[self.view addSubview:button];<br>//当然，就这么执行程序是没有任何效果的，我们看不到Button出现在View上。</p><p>//用于存储约束<br>NSMutableArray *constraints = [NSMutableArray array];</p><p>//添加按钮的水平约束，意思是该按钮宽度90，距离父控件右边30。<br>[constraints<br>addObjectsFromArray:<br>[NSLayoutConstraint<br>constraintsWithVisualFormat:@”H:[button(90)]-30-|”<br>options:0<br>metrics:nil<br>views:NSDictionaryOfVariableBindings(<br>button)]];</p><p>//添加按钮的垂直约束，意思是该按钮高度40，距离父控件上边100。<br>[constraints<br>addObjectsFromArray:<br>[NSLayoutConstraint<br>constraintsWithVisualFormat:@”V:|-100-[button(40)]”<br>options:0<br>metrics:nil<br>views:NSDictionaryOfVariableBindings(<br>button)]];</p><p>//将约束添加到View中。<br>[self.view addConstraints:constraints];<br>}<br><br>看完例子有木有觉得很简单，很有趣？</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> VFL </tag>
            
            <tag> 自动布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯子推荐</title>
      <link href="/2014/12/04/%E6%A2%AF%E5%AD%90%E6%8E%A8%E8%8D%90/"/>
      <url>/2014/12/04/%E6%A2%AF%E5%AD%90%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>作为IT从业者，好用的梯子可以说是必备之物。在这里我推荐<a href="http://honx.in/i/U6jd04Ko13KmmIiD" target="_blank" rel="noopener">红杏</a>。<br>它是一款Chrome、FireFox插件，相较于VPN等，使用简单方便，价格便宜(每月10元)，且不限流量。唯一的缺点是只能在浏览器上使用，当然他们的客服说目前正在开发不依赖浏览器的版本，很值得期待。</p><p>PS:我一般是配合VPN使用的。只是在网上查查资料的话就用红杏足矣。如果涉及本地应用需要梯子，我用的是<a href="https://www.123ssh.net/" target="_blank" rel="noopener">123SSH</a>，价格比红杏略贵，配合GoAgent可以实现按规则翻墙，就是配置起来还是比较麻烦，不如红杏那么简单易用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GFW </tag>
            
            <tag> 翻墙 </tag>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记四</title>
      <link href="/2014/11/19/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2014/11/19/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>Swift中的集合类型，数组和字典与Objective-C中相比，最大的不同就是<strong>类型安全</strong>。例如：如果我们创建了一个Int值类型的数组，我们就不能往其中插入任何不是Int类型的数据。</p><pre><code>//我们创建一个人员数组。var employees : [String] = ["Jack","Mike"]</code></pre>实际上上面的数组我们利用Swift的推断特性，还可以写成这样<pre><code>var employees = ["Jack","Mike"]</code></pre><pre><code>//创建一个空数组var array=Array<string>()//或者var array=[String]</string></code></pre><p>count属性用于后去数组的Item数量。<br>isEmpty属性可以快速的检测count是否为0。<br>append方法可以用于追加新的数据项。<br>for-in用于遍历数组。<br>我们可以使用+操作符来组合两个相同类型的数组。</p><p>字典在Swift中也是类型安全的，字典使用Dictionary&lt;KeyType, ValueType&gt;定义,其中KeyType是字典中键的数据类型，ValueType是字典中对应于这些键所存储值的数据类型。</p><p>KeyType的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如String，Int， Double和Bool）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。</p><pre><code>//定义机场的缩写和全称var airports: Dictionary<string, string=""> = ["TYO": "Tokyo", "DUB": "Dublin"]//或者这样定义var airports= ["TYO": "Tokyo", "DUB": "Dublin"]</string,></code></pre><p><strong>如果集合遍历被定义为var，那么就是可变的。数组中的长度和其中的元素可以被修改，字典的长度和其中的元素也可以被修改。如果被定义为let，则不允许被修改。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手势的使用</title>
      <link href="/2014/11/19/%E6%89%8B%E5%8A%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2014/11/19/%E6%89%8B%E5%8A%BF%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>iOS让人着迷的地方之一，就是无与伦比的手势操作。记得大学时第一次看到双指缩放图片时的惊奇，以至于玩图片库可以玩一节课。在这里我收集整理一下手势的用法。</p><p>iOS中，与手势相关的类继承自UIKit中的UIGestureRecognizer类，它是一个<a href="https://en.wikipedia.org/wiki/Abstract_type" target="_blank" rel="noopener">抽象类</a>，定义了所有手势的基本行为，iOS支持的所有基础手势如下：</p><ul><li>UITapGestureRecognizer 拍击，任意次数的拍击。</li><li>UIPinchGestureRecognizer 向里或向外捏，用于缩放。</li><li>UIPanGestureRecognizer 拖拽。</li><li>UISwipeGestureRecognizer 任意方法的擦碰。</li><li>UIRotationGestureRecognizer 旋转，比如旋转照片。</li><li>UILongPressGestureRecognizer 长按。</li></ul><p>####UITapGestureRecognizer####<br>这是我个人用得比较多的一个手势，主要是给没有点击事件的控件添加单击事件。比如给UIImageView添加单击功能。</p><script src="https://gist.github.com/yuxiangq/b56b55a42585a8a18d0f.js"></script><p><strong>setNumberOfTapsRequired</strong> 方法设置拍击几次响应。<br><strong>setNumberOfTouchesRequired</strong> 方法设置几个手指拍击。</p><p>####UILongPressGestureRecognizer####<br>长按手势就我个人而言，用得次多的手势。主要用于一些隐藏得，有明确指向目标的逻辑触发。</p><script src="https://gist.github.com/yuxiangq/4dfeebc687b459b629bc.js"></script><p>####UISwipeGestureRecognizer和UIPanGestureRecognizer####<br>擦碰手势和拖动手势有很相似的地方，所以有些童鞋弄得不是很清楚，所以放到一起将。<br>擦碰手势，分上下左右四个方向，它只是侦测你手指在屏幕上轻扫的方向，然后进行一些功能。</p><script src="https://gist.github.com/yuxiangq/ad389e9c32eaec44fc78.js"></script><p>拖动手势UIPanGestureRecognizer与擦碰手势有个最大的区别是，拖动手势手指始终要在屏幕上。而擦碰手势，手指最后是离开屏幕的。</p><script src="https://gist.github.com/yuxiangq/f166cf725ce21cb78f95.js"></script>-(CGPoint)translationInView:(UIView *)view 方法返回拖动的距离，传入的view是参照物。-(CGPoint)velocityInView:(UIView *)view 方法返回拖动的速度，传入的view是参照物。####UIPinchGestureRecognizer和UIRotationGestureRecognizer####这两个手势我都没有使用过o(╯□╰)o<script src="https://gist.github.com/yuxiangq/af83a2477e014f5f79b9.js"></script><script src="https://gist.github.com/yuxiangq/de8a69b4873c4b02be32.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 手势 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记三</title>
      <link href="/2014/10/26/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2014/10/26/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>这一部分主要了解运算符，因为大部分编程语言的运算符都相似，所以在这里我只记录有Swift特色的运算符。</p><p>###区间运算符###<br>Swift 提供了两个方便表达一个区间的值的运算符</p><p>####闭区间运算符####<br>闭区间运算符（a…b）定义一个包含从a到b(包括a和b)的所有值的区间，b必须大于a。 ‌ 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在for-in循环中</p><pre><code>for index in 1...5  {println("\(index) * 5 = \(index * 5)")}// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20// 5 * 5 = 25</code></pre>####半开区间运算符####半开区间（a..<b）定义一个从a到b但不包括b的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。="" <pre=""><code>for index in 1...< 5  {println("\(index) * 5 = \(index * 5)")}// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20</code><p>###空合运算符###<br>空合运算符(a ?? b)将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b.这个运算符有两个条件</p><ul><li>表达式a必须是Optional类型</li><li>默认值b的类型必须要和a存储值的类型保持一致</li></ul><pre><code>let defaultColorName = "red"var userDefinedColorName:String?   //默认值为nilvar colorNameToUse = userDefinedColorName ?? defaultColorName//userDefinedColorName的值为空 ，所以colorNameToUse的值为red</code></pre><p>实际上该运算符我在C#中早已接触过，确实是非常好用，配合可空类型，使代码相当优雅。</p></b）定义一个从a到b但不包括b的区间。>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记二</title>
      <link href="/2014/10/23/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2014/10/23/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>Swift是一门类型安全的语言，Swift中包含的基础数据类型有以下7种</p><ul><li>Int 整型，长度与当前平台的原生字长相同。在32位平台上，Int和Int32相同；在64位平台上和Int64相同。</li><li>Double 浮点型，表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li><li>Float 浮点型，表示32位浮点数。精度要求不高的话可以使用此类型。</li><li>Bool 布尔型</li><li>String 字符串</li><li>Array 数组集合</li><li>Dictinary 词典集合</li></ul><p>Swift中还包含Objective-C中不包含的高阶数据类型比如元组(Tuple)，用它可以很方便的通过一个函数返回多个值。</p><p><strong>声明常量和变量</strong></p><pre><code>//常量let a=0//变量var b=1</code></pre><p><strong>类型标注</strong></p><pre><code>let num:Int = 1let str:String = "test"</code></pre>*注意：**Swift支持类型推断，可以不用进行标注，Swift会根据你初始化该变量或常量使用的值，推断出类型。***Hello world**<pre><code>println(“hello world”)</code></pre>println是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，println将会输出内容到“console”面板上。(另一种函数叫print，唯一区别是在输出内容最后不会换行。)与 Cocoa 里的NSLog函数类似的是，println函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：<pre><code>let str="hello world"println("this is \(str)") //this is hello world</code></pre><p><strong>类型安全和类型推断</strong></p><p>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。</p><p>当你定义变量或常量，如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p><p><strong>类型别名</strong></p><p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。</p><pre><code>typealias MyInt=Intvar a:MyInt=0</code></pre><p><strong>元组</strong></p><p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p><p>下面这个例子中，(404, “Not Found”)是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个404 Not Found状态码。</p><pre><code>let http404Error = (404, "Not Found")// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")</code></pre><p>并且可以很方便的将元组的内容分解</p><p><pre><code><br>let (statusCode, statusMessage) = http404Error<br>println(“The status code is (statusCode)”)<br>// 输出 “The status code is 404”<br>println(“The status message is (statusMessage)”)<br>// 输出 “The status message is Not Found”<br></code></pre><br>你可以在定义元组的时候给单个元素命名，给元组中的元素命名后，你可以通过名字来获取这些元素的值</p><p><pre><code><br>let http200Status = (statusCode: 200, description: “OK”)<br>println(“The status code is (http200Status.statusCode)”)<br>// 输出 “The status code is 200”<br>println(“The status message is (http200Status.description)”)<br>// 输出 “The status message is OK”<br></code></pre><br><em>注意：</em><br><em>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。</em></p><p><strong>可选类型(可空类型)</strong><br>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示：</p><ul><li>有值，等于 x</li></ul><p>或者</p><ul><li>没有值</li></ul><p>这个特性类似于C#中的可空类型，甚至表示方式都近似。<br>在我们与数据库交互的时候，可空值是非常重要的。因为数据库中的所有类型都是允许null的。</p><p><em>注意：</em><br><em>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</em></p><p>来看一个例子。Swift 的String类型有一个叫做toInt的方法，作用是将一个String值转换成一个Int值。然而，并不是所有的字符串都可以转换成一个整数。字符串”123”可以被转换成数字123，但是字符串”hello, world”不行。</p><p>下面的例子使用toInt方法来尝试将一个String转换成Int</p><p><pre><code><br>let possibleNumber = “123”<br>let convertedNumber = possibleNumber.toInt()<br>// convertedNumber 被推测为类型 “Int?”， 或者类型 “optional Int”<br></code></pre><br>因为toInt方法可能会失败，所以它返回一个可选类型（optional）Int，而不是一个Int。一个可选的Int被写作Int?而不是Int。问号暗示包含的值是可选类型，也就是说可能包含Int值也可能不包含值。（不能包含其他任何值比如Bool值或者String值。只能是Int或者什么都没有。）</p><p><strong>if语句及强制解析</strong><br>可以使用if语句来判断一个可空值是否包含值。如果有值，则可通过在可空值变量后添加「感叹号」的方式获取该值，比如</p><p><pre><code><br>if convertedNumber != nil {<br>println(“(possibleNumber) has an integer value of (convertedNumber!)”)<br>} else {<br>println(“(possibleNumber) could not be converted to an integer”)<br>}<br></code></pre><br><em>注意：</em><br><em>使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。</em></p><p><strong>可选绑定</strong><br>使用可选绑定重写上面的例子为</p><p><pre><code><br>if let actualNumber = possibleNumber.toInt() {<br>println(“(possibleNumber) has an integer value of (actualNumber)”)<br>} else {<br>println(“(possibleNumber) could not be converted to an integer”)<br>}<br>// 输出 “123 has an integer value of 123”<br></code></pre><br>这段代码可以被理解为：</p><p>“如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”</p><p>如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。</p><p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作actualNumber的值，你可以改成if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p><p><em>注意：</em><br><em>Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，nil是一个指向不存在对象的指针。在 Swift 中，nil不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为nil，不只是对象类型。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记一</title>
      <link href="/2014/10/12/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2014/10/12/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>随着6月初WWDC 2014的落幕，iOS程序员圈子里掀起了学习Swift的热潮，预计再过2年，Swift将成为开发Mac OS X/iOS 程序的主力语言。</p><p>最近在群里和论坛上，都看到初学者在问，到底是学Objective-C好还是Swift好。其实我认为，与其这样纠结的各个群、各个论坛的询问，不如二者一起学习(Objective-C为主，Swift为辅)。毕竟现阶段一般都会支持iOS 7/8，在国内环境也很难做到只支持iOS 8，甚至会要求支持到iOS 5/6。所以作为iOS程序员，Objective-C是不能缺的技能，优先学习Objective-C是没有问题的。而Swift替代Objective-C我相信还有很长的时间，尤其是在国内环境，时间应该会更长一点。毕竟国内要求支持的iOS版本跨度更大。</p><p>根据WWDC 2014上的介绍 <em>Swift 是一种新的编程语言，用于编写 iOS 和 OS X 应用。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</em> 通过以上的介绍，我们可以很清晰的了解到，对于熟悉Cocoa 和 Cocoa Touch的程序员来说，从Objective-C迁移到Swift是一件很轻松的事情，毕竟学一门语言，就是在学库，既然两者库是通用的，那么只需要了解基本语法，就能完成部分工作了。剩下的就是学习语言的高级特性，重构代码。</p><p>从目前的介绍来看，Swift颇有脚本语言的风格。<em>它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的编程语言。它支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</em>我真是迫不及待的想开始学习它了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学VB时的回忆</title>
      <link href="/2014/09/27/%E8%87%AA%E5%AD%A6VB%E6%97%B6%E7%9A%84%E5%9B%9E%E5%BF%86/"/>
      <url>/2014/09/27/%E8%87%AA%E5%AD%A6VB%E6%97%B6%E7%9A%84%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p>前几天在知乎上看到一个问题——<a href="http://www.zhihu.com/question/25526940/answer/31006493" target="_blank" rel="noopener">如果每天坚持用12个小时学习一门编程语言，一年下来，编程能力会达到什么程度？</a>。其中<a href="http://www.zhihu.com/people/vczh-the-wise" target="_blank" rel="noopener">轮子哥</a>的回答，不禁让自己想起了初中时代学习VB的事情。</p><p>说来惭愧，轮子哥初中时代学习VB，现在已是一方大牛，自己初中时代也买了本VB学习，现在还是一方码农，这就是命啊。<br>家里初一的时候，买了第一台电脑，记得配置是赛扬445，内存128M，自己是爱不释手，各种折腾。慢慢自己折腾会了装系统，使用虚拟光驱，知道了什么是镜像，什么是快捷方式=。=，当然很大一部分时间实在网络上各种闲逛，还有玩经典的单机游戏和模拟器。当时很喜欢买的杂志是《模拟时代》和《模拟XX》(名字忘了。。。反正也是挺出名的)，因为自己是一个很热爱游戏的人，小学的时候就混迹于街机厅和PS游戏室，在电脑上发现了模拟器这个东西的时候真是如获至宝，天天玩得不亦乐乎。当时主要玩GBA模拟器，《火焰纹章 烈火之剑》《恶魔城》三作，我都是在上面通关的，当然还有CPS1&amp;2主板上的经典游戏。后来慢慢的很崇拜模拟器的作者，就很想自己学习编写模拟器，不过当时自己不知道怎么入门，于是在网上找资料，其实自己当时连HTML、C、VB这些的区别都不知道，就看论坛上得人们怎么说，学什么更好入门。后来自己就直接跑到新华书店，去计算机图书区看看有些什么书。先看了一本C语言，看着里面的Helloworld，着实提不起兴趣，和自己想想中的写出模拟器的语言相差很大。正好旁边放着一本Visual Basic 6.0程序设计，于是拿起来翻了翻，真是让我眼前一亮。第一篇的Helloword就是熟悉的窗体，这才是做模拟器的语言哎╮(╯▽╰)╭。于是果断将此书买回家，下了个VB开始弄，第一篇helloword我是将整个实例程序都敲了一遍，包括注释(当时我还不理解什么叫「注释」，以为是程序不可分割的一部分)。但是程序始终跑不起来，原因嘛，我相信初学编程的朋友都遇到过，就是符号全角和半角的问题。当时自己实在是二，还拿着书跑去学校问计算机课老师，结果老师表示也不懂，无奈放弃了。倘若在你初学的时候，身边有个有经验的人能点拨你一下，能取得事倍功半的效果。</p><p>后来，这本书就这样静静得躺在了书柜里，偶尔被翻出来，学习一下，但是一直没能跨过入门那道坎。现在想来，自己那个时候自学的能力真是差劲，倘若能很好的利用网络资源的话，估计我的程序人生会提前一大步，哈哈。<br>考上大学的时候，义无反顾的选择了软件开发专业，虽然挺多人觉得这个专业的人滥大街了，所以很多同学选择了土木、生物等相关朝阳专业，不过对我而言，能做自己喜欢的事情才是最重要的。<br>大学报到的时候将那本书带去了学校，毕业以后又随我留在了工作的城市。不知可否成为一件传家宝，就这么传承下去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于指针及指针变量</title>
      <link href="/2014/09/05/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%8F%8A%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/"/>
      <url>/2014/09/05/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%8F%8A%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>我在刚学习C语言的时候，一直不能很好的理解<strong>指针</strong>和<strong>指针变量</strong>(再加上神马函数指针，指针函数，指针的指针，有木有觉得绕晕了？o(╯□╰)o)。后来慢慢的有点感觉了，想到一种巧妙的理解方式。</p><p>大家都用过Windos系统(废话o(╯□╰)o)，Windows桌面上都会有快捷方式(想起小时候还做过蠢事。那个时候初一，家里买了电脑，自己去网吧拷游戏玩。将桌面上所有游戏拷到一个U盘里面，当然全是快捷方式，当时还在纳闷为啥游戏拷得那么快。。。。太糗了)，快捷方式并不是真正的程序，而是指向程序的一个变量(图标)。快捷方式就像指针变量，他保存的是指针(程序在硬盘上的真实地址)，通过它我们能找到硬盘上真正的程序并且运行。</p><p>现在有木有一种豁然开朗的感觉?另外刚学C语言的时候，我们老师说可以将书中出现的<strong>指针</strong>替换为<strong>地址</strong>，这样就能更好的理解，比如<strong>函数指针</strong>等于<strong>函数地址</strong>，<strong>指针函数</strong>等于<strong>地址函数</strong>(感觉比较怪，即该函数的返回值为地址)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 指针变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIImageView展示大图学习笔记</title>
      <link href="/2014/08/30/UIImageView%E5%B1%95%E7%A4%BA%E5%A4%A7%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2014/08/30/UIImageView%E5%B1%95%E7%A4%BA%E5%A4%A7%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>UIImageView展示超大分辨率图片，我们主要通过Apple官方实例<a href="https://developer.apple.com/library/ios/samplecode/LargeImageDownsizing/Introduction/Intro.html" target="_blank" rel="noopener"><strong>Large Image Downsizing</strong></a>来进行学习。</p><p>官方实例中，用于展示的图片<em>large_leaves_70mp.jpg</em>，分辨率达到了惊人的7033 × 10110。要展示这么一张图片，我相信大家都能立即意识到，通过通常方法(imageView.image=image)是无法正常显示的。Apple的文档和实例给我了我们一个很好的思路。</p><p>针对这个问题，我们的Android工程师的解决方案是将图片按照屏幕分辨率进行等比裁剪。及针对7033 <em> 10110分辨率的图片为了在1280 </em> 720分辨率的手机上展示成功，至少会把原图裁剪为703 * 1011。这样可以大幅减少显示图片的内存消耗，基本解决了APP显示大图的问题。但是这样总会有不足，假设有款手机分辨率是1080P，但只有512MB ROM(这个例子比较极端)，那么上面那种按照屏幕分辨率的裁剪方式就会有问题，图片依然没法正确显示。Apple Sample中的做法是利用QuartzCore来进行绘制，并且将图片分割成多个Tile进行绘制。</p><p>官方实例中，首先获取了原始图片的高度和宽度</p><pre><code>/* 获取原始照片的宽度和高度 */sourceResolution.width = CGImageGetWidth(sourceImage.CGImage);sourceResolution.height = CGImageGetHeight(sourceImage.CGImage);</code></pre>[CGImageGetWidth和UIImage.size.width方法返回的结果都是一样的，照片宽有多少像素。前者效率更高。评论中有人提到并不一样，大家可以参考。主要分歧是UIImage.size.width是否受scale的影响](http://stackoverflow.com/questions/12954319/is-difference-between-cgimagegetwidthworkingimage-cgimage-and-workingimage-siz)计算图片的总像素<pre><code>sourceTotalPixels = sourceResolution.width * sourceResolution.height;</code></pre><p>计算未压缩的图片占用多大内存</p><pre><code>sourceTotalMB = sourceTotalPixels / pixelsPerMB;</code></pre><p>计算缩放比例</p><pre><code>imageScale = destTotalPixels / sourceTotalPixels;</code></pre><p>计算缩放后的宽度和高度，公式为 <strong>缩放后高度=原高度 * 缩放比例</strong></p><pre><code>destResolution.width = (int)(sourceResolution.width * imageScale);destResolution.height = (int)(sourceResolution.height * imageScale);</code></pre><p>接下来我们进行绘图工作,首先获取当前设备的色彩空间(色彩范围)。</p><pre><code>CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();//计算缩放后的图片每一行的字节数。int bytesPerRow = bytesPerPixel * destResolution.width;</code></pre><p>为需要显示的图片分配足够的像素空间。</p><pre><code>void *destBitmapData = malloc(bytesPerRow * destResolution.height);</code></pre><p><a href="http://blog.csdn.net/wangyuchun_799/article/details/7804809" target="_blank" rel="noopener">CGBitmapContextCreate函数参数详解</a></p><pre><code>//创建输出图像的上下文destContext = CGBitmapContextCreate(destBitmapData/*输出图片需要的像素地址*/, destResolution.width/*输出图片的宽度*/, destResolution.height/*输出图片的高度*/, 8/*内存中像素的每个组件的位数.例如，对于32位像素格式和RGB 颜色空间，你应该将这个值设为8*/, bytesPerRow/*输出图片每行字节数*/, colorSpace/*当前设备色彩范围*/, kCGImageAlphaPremultipliedLast);</code></pre><p>对需要展示的位图进行移动和缩放，是我们能够在屏幕上看清图片全貌。</p><pre><code>//移动图片CGContextTranslateCTM(destContext, 0.0f, destResolution.height);//缩放图片CGContextScaleCTM(destContext, 1.0f, -1.0f);</code></pre><p>虽然我们对超大图片进行了缩放，但是依然较大，特别是在绘制的时候，非常耗性能。所以Sample中的方法是将该图的绘制分成多个Tile来进行，在该Sample中这张图片被分成了14个Tile。sourceTile表示从原图上截取的Tile尺寸，destTile表示最终绘制到界面上的Tile尺寸。</p><pre><code>//源Tile的宽度和原图一直sourceTile.size.width = sourceResolution.width;/ * 源Tile的高度等于 **Tile的总像素/Tile的宽度(因为我们从前面了解到，图片的总像素=高度 * 宽度)** Tile用于从原图中截取图片，经过转换变为目标Tile * /sourceTile.size.height = (int)(tileTotalPixels / sourceTile.size.width);NSLog(@"source tile size: %f x %f", sourceTile.size.width,sourceTile.size.height);sourceTile.origin.x = 0.0f;//目标Tile的高度和宽度destTile.size.width = destResolution.width;destTile.size.height = sourceTile.size.height * imageScale;destTile.origin.x = 0.0f;NSLog(@"dest tile size: %f x %f", destTile.size.width, destTile.size.height);// the source seem overlap is proportionate to the destination seem overlap.// this is the amount of pixels to overlap each tile as we assemble the ouput// image.sourceSeemOverlap = (int)((destSeemOverlap / destResolution.height) *sourceResolution.height);NSLog(@"dest seem overlap: %f, source seem overlap: %f", destSeemOverlap,sourceSeemOverlap);CGImageRef sourceTileImageRef;//获取迭代次数，用于表示需要几次读取绘制能将图片展示完毕。int iterations = (int)(sourceResolution.height / sourceTile.size.height);//剩余高度int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;if (remainder)iterations++;// add seem overlaps to the tiles, but save the original tile height for y// coordinate calculations.float sourceTileHeightMinusOverlap = sourceTile.size.height;sourceTile.size.height += sourceSeemOverlap;destTile.size.height += destSeemOverlap;NSLog(@"beginning downsize. iterations: %d, tile height: %f, remainder "@"height: %d",iterations, sourceTile.size.height, remainder);//开始读取绘制图片for (int y = 0; y < iterations; ++y) {// create an autorelease pool to catch calls to -autorelease made within the// downsize loop.NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];NSLog(@"iteration %d of %d", y + 1, iterations);//计算员Tile坐标sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;//目标Tile坐标destTile.origin.y =(destResolution.height) -((y + 1) * sourceTileHeightMinusOverlap * imageScale + destSeemOverlap);// create a reference to the source image with its context clipped to the// argument rect./ * 获取源图片的一部分，生成sourceTileImageRef，不要忘记一开始我们就将原图保存在了sourceImage.CGImage * /sourceTileImageRef =CGImageCreateWithImageInRect(sourceImage.CGImage, sourceTile);/ * 判断是否是最后一次迭代，并有剩余高度的图片，不能组成一个Tile * /if (y == iterations - 1 && remainder) {float dify = destTile.size.height;destTile.size.height = CGImageGetHeight(sourceTileImageRef) * imageScale;dify -= destTile.size.height;destTile.origin.y += dify;}//将获取到的源Tile按照目标Tile的尺寸绘制到界面上CGContextDrawImage(destContext, destTile, sourceTileImageRef);/* release the source tile portion pixel data. note,releasing the sourceTileImageRef doesn't actually release the tile portionpixeldata that we just drew, but the call afterward does. */CGImageRelease(sourceTileImageRef);/* while CGImageCreateWithImageInRect lazily loads just the image datadefined by the argument rect,that data is finally decoded from disk to mem when CGContextDrawImage iscalled. sourceTileImageRefmaintains internally a reference to the original image, and that originalimage both, houses andcaches that portion of decoded mem. Thus the following call to release thesource image. */[sourceImage release];// free all objects that were sent -autorelease within the scope of this// loop.[pool2 drain];// we reallocate the source image after the pool is drained since UIImage// -imageNamed// returns us an autoreleased object.//判断绘制是否结束，如果没有则继续读取原图，进行后续绘制工作。if (y < iterations - 1) {sourceImage = [[UIImage alloc]initWithContentsOfFile:[[NSBundle mainBundle]pathForResource:kImageFilenameofType:nil]];[self performSelectorOnMainThread:@selector(updateScrollView:)withObject:nilwaitUntilDone:YES];}}NSLog(@"downsize complete.");//将绘制完毕的图片在ScrollView进行展示[self performSelectorOnMainThread:@selector(initializeScrollView:)withObject:nilwaitUntilDone:YES];// free the context since its job is done. destImageRef retains the pixel data// now.CGContextRelease(destContext);[pool drain];</code></pre><p>该Sample本人看起来还是颇为吃力，只能边看边学。目前大致只能理解到这种程度。我在项目中展示大图的方式更简单暴力，先将图片下载，然后判断未压缩图片占用内存大小。如果超过预设大小，则直接将图片裁剪到预设大小以下再展示。没有采用Sample中的展示方案。//设置你的Cell<br>return cell;<br>}<br><br>在这里推荐用第二种方法，特别是当界面中有多种Cell的情况下，第二种方法在逻辑上更清晰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UIImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UITableViewCell的重用方法的区别</title>
      <link href="/2014/08/16/UITableViewCell%E7%9A%84%E9%87%8D%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2014/08/16/UITableViewCell%E7%9A%84%E9%87%8D%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>UITableView</strong>想必是iOS开发中最常用的控件。很多Apple自带的APP都使用了它，比如:<em>Phone</em>(该APP为典型得Tab结构,其中<em>Favorites</em>,<em>Recents</em>,<em>Contacts</em>都使用了<strong>UITableView</strong>)、<em>Messages</em>、<em>Mail</em>、<em>Settings</em>等等。</p><p><strong>UITableView</strong>最基础的特性莫过于<strong>UITableVIewCell</strong>的重用。讲到这里不得不提我在实习的时候，负责的一个IM功能模块。当时在做聊天窗口的时候，用了ListView来显示聊天信息(这是基于.net平台的一个项目)，当收到聊天消息的时候我做的操作大致如下:</p><pre><code>public void ReceiveMeesage(string text){TextBox txt=new TextBox();txt.Text=text;listBox.Items.Add(txt);}</code></pre><p>或许大家已经看出问题了，随着消息越来越多Item中的控件会越来越多，内存消耗会越来越大，非常影响程序效率。<br>实际上我们并不需要那么多TextBox，假设聊天窗口一次能够展示10条消息，那么实际上我们只需要12个TextBox就能满足展示需要。没错，只需要复用TextBox就行了。在第一个TextBox移除我们视线之后，再将其从后载入，显示新的消息即可。</p><p><strong>UITableView</strong>中实现Cell的重用是非常方便的，关键是DataSource中的两个方法，如下:</p><p><pre><code><br>-(id)dequeuReusableCellWithIdentifier:(NSString<em> )identifier;<br>-(id)dequeueReusableCellWithIdentifier:(NSString</em> )identifier forIndexPath:(NSIndexPath* )indexPath NS_AVAILABLE_IOS(6_0);<br></code></pre><br>后者为<strong>iOS6</strong>加入的方法，两个方法的区别为:<br><strong>前者有可能从队列中返回nil，尤其是第一次执行的时候，Queue中没有任何Cell，需要我们手动创建，如下</strong>:</p><p><pre><code><br>-(UITableViewCell <em> )tableView:(UITableView </em> )tableView cellForRowAtIndexPath:(NSIndexPath <em> )indexPath<br>{<br>static NSString </em> reuseIdentifier=@”cell”;<br>UITableViewCell * cell=[tableView dequeueReusableCellWithIdentifier:reuseIdentifier];<br>if(!cell)<br>{<br>//在这里创建UITableViewCell<br>}<br>//设置你的Cell<br>return cell;<br>}<br></code></pre><br><strong>后者则不需要我们手动创建Cell，只需要提前注册一个原型Cell即可，假如Queue中没有Cell，程序会用原型Cell帮我们创建好，也就是不会出现返回nil的情况，代码如下:</strong></p><p><pre><code><br>-(void)viewDidLoad<br>{<br>//初始化UITableView的时候注册原型Cell<br>UITableView <em> tableView=[[UITableView alloc] init];<br>//调用[tableView registerNib:(UINib </em>) forCellReuseIdentifier:(NSString <em>)];<br>//或tableView registerClass:(__unsafe_unretained Class) forCellReuseIdentifier:(NSString </em>)<br>//注册原型Cell<br>self.view=tableView;<br>}</code></pre></p><p>-(UITableViewCell <em> )tableView:(UITableView </em> )tableView cellForRowAtIndexPath:(NSIndexPath <em> )indexPath<br>{<br>UITableViewCell </em> cell=[tableView dequeueReusableCellWithIdentifier:reuseIdentifier forIndexPath:(NSIndexPath * )indexPath];<br>//设置你的Cell<br>return cell;<br>}<br><br>在这里推荐用第二种方法，特别是当界面中有多种Cell的情况下，第二种方法在逻辑上更清晰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UITableVIewCell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
